{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction AnchorPy is the gateway to interacting with Anchor programs in Python. It provides: A static client generator A dynamic client similar to anchor-ts A Pytest plugin A CLI with various utilities for Anchor Python development. Installation (requires Python >= 3.9) pip install anchorpy [ cli, pytest ] Or, if you're not using the CLI or Pytest plugin features of AnchorPy you can just run pip install anchorpy . Note These docs will assume you've read the Anchor documentation first.","title":"Introduction"},{"location":"#introduction","text":"AnchorPy is the gateway to interacting with Anchor programs in Python. It provides: A static client generator A dynamic client similar to anchor-ts A Pytest plugin A CLI with various utilities for Anchor Python development.","title":"Introduction"},{"location":"#installation-requires-python-39","text":"pip install anchorpy [ cli, pytest ] Or, if you're not using the CLI or Pytest plugin features of AnchorPy you can just run pip install anchorpy . Note These docs will assume you've read the Anchor documentation first.","title":"Installation (requires Python &gt;= 3.9)"},{"location":"cli/","text":"AnchorPy CLI AnchorPy comes with a CLI to make your life easier when using Python with Anchor. $ anchorpy --help Usage: anchorpy [OPTIONS] COMMAND [ARGS]... AnchorPy CLI. Options: --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Commands: init Create a basic Python test file for an Anchor program. shell Start IPython shell with AnchorPy workspace object initialized. Commands Init $ anchorpy init --help Usage: anchorpy init [OPTIONS] PROGRAM_NAME Create a basic Python test file for an Anchor program. This does not replace `anchor init`, but rather should be run after it. The test file will live at `tests/test_$PROGRAM_NAME.py`. Arguments: PROGRAM_NAME The name of the Anchor program. [required] Options: --help Show this message and exit. Shell $ anchorpy shell --help Usage: anchorpy shell [OPTIONS] Start IPython shell with AnchorPy workspace object initialized. Note that you should run `anchor localnet` before `anchorpy shell`. Options: --help Show this message and exit. Example $ cd anchor/examples/tutorial/basic-0 && anchorpy shell Python 3.9.1 (default, Dec 11 2020, 14:32:07) Type 'copyright', 'credits' or 'license' for more information IPython 7.30.1 -- An enhanced Interactive Python. Type '?' for help. Hint: type `workspace` to see the Anchor workspace object. # In [ 1 ] :$ await workspace [ \"basic_0\" ] .rpc [ \"initialize\" ]() Out[1]: '2q1Z8BcsSBikMLEFoeFGhUukfsNYLJx7y33rMZ57Eh4gAHJxpJ9oP9b9aFyrizh9wcuiVtAAxvmBifCXdqWeNLor' Client-gen See Client Generator","title":"AnchorPy CLI"},{"location":"cli/#anchorpy-cli","text":"AnchorPy comes with a CLI to make your life easier when using Python with Anchor. $ anchorpy --help Usage: anchorpy [OPTIONS] COMMAND [ARGS]... AnchorPy CLI. Options: --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Commands: init Create a basic Python test file for an Anchor program. shell Start IPython shell with AnchorPy workspace object initialized.","title":"AnchorPy CLI"},{"location":"cli/#commands","text":"","title":"Commands"},{"location":"cli/#init","text":"$ anchorpy init --help Usage: anchorpy init [OPTIONS] PROGRAM_NAME Create a basic Python test file for an Anchor program. This does not replace `anchor init`, but rather should be run after it. The test file will live at `tests/test_$PROGRAM_NAME.py`. Arguments: PROGRAM_NAME The name of the Anchor program. [required] Options: --help Show this message and exit.","title":"Init"},{"location":"cli/#shell","text":"$ anchorpy shell --help Usage: anchorpy shell [OPTIONS] Start IPython shell with AnchorPy workspace object initialized. Note that you should run `anchor localnet` before `anchorpy shell`. Options: --help Show this message and exit.","title":"Shell"},{"location":"cli/#example","text":"$ cd anchor/examples/tutorial/basic-0 && anchorpy shell Python 3.9.1 (default, Dec 11 2020, 14:32:07) Type 'copyright', 'credits' or 'license' for more information IPython 7.30.1 -- An enhanced Interactive Python. Type '?' for help. Hint: type `workspace` to see the Anchor workspace object. # In [ 1 ] :$ await workspace [ \"basic_0\" ] .rpc [ \"initialize\" ]() Out[1]: '2q1Z8BcsSBikMLEFoeFGhUukfsNYLJx7y33rMZ57Eh4gAHJxpJ9oP9b9aFyrizh9wcuiVtAAxvmBifCXdqWeNLor'","title":"Example"},{"location":"cli/#client-gen","text":"See Client Generator","title":"Client-gen"},{"location":"clientgen/","text":"Client Generator The anchorpy client-gen command generates a Python client based on an Anchor IDL. This client provides functions for generating instructions and class definitions for fetching and serializing accounts. The output is very similar to the Typescript code produced by anchor-client-gen . Features Fully typed. Supports all Anchor field types. Makes enums and complex types easy to work with. Generates error classes for each error. Provides to_json and from_json utility functions for types and accounts. Note It is recommended to use the generated client instead of the dynamic client where possible, as it is easier to work with and comes with proper type hints. Usage $ anchorpy client-gen --help Usage: anchorpy client-gen [OPTIONS] IDL OUT Generate Python client code from the specified anchor IDL. Arguments: IDL Anchor IDL file path [required] OUT Output directory. [required] Options: --program-id TEXT Optional program ID to be included in the code --help Show this message and exit. Example $ anchorpy client-gen path/to/idl.json ./my_client generating package... generating program_id.py... generating errors.py... generating instructions... generating types... generating accounts... This will generate code to ./my_client : . \u251c\u2500\u2500 accounts \u2502 \u251c\u2500\u2500 foo_account.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 instructions \u2502 \u251c\u2500\u2500 some_instruction.py \u2502 \u251c\u2500\u2500 other_instruction.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 types \u2502 \u251c\u2500\u2500 bar_struct.py \u2502 \u251c\u2500\u2500 baz_enum.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 errors \u2502 \u251c\u2500\u2500 anchor.py \u2502 \u251c\u2500\u2500 custom.py \u2502 \u2514\u2500\u2500 __init__.py \u2514\u2500\u2500 program_id.py Using the generated client Instructions from solders.hash import Hash from solders.keypair import Keypair from solders.message import Message from solders.pubkey import Pubkey from solders.transaction import Transaction from anchorpy import Provider from my_client.instructions import some_instruction # call an instruction foo_account = Keypair () # in real use, fetch this from an RPC recent_blockhash = Hash . default () ix = some_instruction ({ \"foo_param\" : \"...\" , \"bar_param\" : \"...\" , ... }, { \"foo_account\" : foo_account . pubkey (), # signer \"bar_account\" : Pubkey ( \"...\" ), ... }) msg = Message ( instructions = [ instruction ], payer = payer . pubkey ()) tx = Transaction ([ payer ], msg , recent_blockhash ) provider = Provider . local () await provider . send ( tx ) Accounts from solders.pubkey import Pubkey from my_client.accounts import FooAccount # fetch an account addr = Pubkey ( \"...\" ) acc = await FooAccount . fetch ( connection , addr ) if acc is None : # the fetch method returns null when the account is uninitialized raise ValueError ( \"account not found\" ) # convert to a JSON object obj = acc . to_json () print ( obj ) # load from JSON acc_from_json = FooAccount . from_json ( obj ) Types # structs from my_client.types import BarStruct bar_struct = BarStruct ( some_field = \"...\" , other_field = \"...\" , ) print ( bar_struct . to_json ()) # enums from my_client.types import baz_enum tuple_enum = baz_enum . SomeTupleKind (( True , False , \"some value\" )) struct_enum = baz_enum . SomeStructKind ({ \"field1\" : \"...\" , \"field2\" : \"...\" , }) disc_enum = baz_enum . SomeDiscriminantKind () print ( tuple_enum . toJSON (), struct_enum . toJSON (), disc_enum . toJSON ()) # types are used as arguments in instruction calls (where needed): ix = some_instruction ({ \"some_struct_field\" : bar_struct , \"some_enum_field\" : tuple_enum , # ... }, { # accounts # ... }) # in case of struct fields, it's also possible to pass them as objects: ix = some_instruction ({ \"some_struct_field\" : { \"some_field\" : \"...\" , \"other_field\" : \"...\" , }, # ..., }, { # accounts # ... }) Errors from solana.rpc.core import RPCException from my_client.errors import from_tx_error from my_client.errors.custom import SomeCustomError try : await provider . send ( tx , [ payer ]) except RPCException as exc : parsed = from_tx_error ( exc ) raise parsed from exc Program ID The client generator pulls the program ID from: the input IDL the --program-id flag If the IDL doesn't contain the program ID then you will need to pass it via the --program-id flag. This program ID is then written into the program_id.py file.","title":"Client Generator"},{"location":"clientgen/#client-generator","text":"The anchorpy client-gen command generates a Python client based on an Anchor IDL. This client provides functions for generating instructions and class definitions for fetching and serializing accounts. The output is very similar to the Typescript code produced by anchor-client-gen .","title":"Client Generator"},{"location":"clientgen/#features","text":"Fully typed. Supports all Anchor field types. Makes enums and complex types easy to work with. Generates error classes for each error. Provides to_json and from_json utility functions for types and accounts. Note It is recommended to use the generated client instead of the dynamic client where possible, as it is easier to work with and comes with proper type hints.","title":"Features"},{"location":"clientgen/#usage","text":"$ anchorpy client-gen --help Usage: anchorpy client-gen [OPTIONS] IDL OUT Generate Python client code from the specified anchor IDL. Arguments: IDL Anchor IDL file path [required] OUT Output directory. [required] Options: --program-id TEXT Optional program ID to be included in the code --help Show this message and exit.","title":"Usage"},{"location":"clientgen/#example","text":"$ anchorpy client-gen path/to/idl.json ./my_client generating package... generating program_id.py... generating errors.py... generating instructions... generating types... generating accounts... This will generate code to ./my_client : . \u251c\u2500\u2500 accounts \u2502 \u251c\u2500\u2500 foo_account.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 instructions \u2502 \u251c\u2500\u2500 some_instruction.py \u2502 \u251c\u2500\u2500 other_instruction.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 types \u2502 \u251c\u2500\u2500 bar_struct.py \u2502 \u251c\u2500\u2500 baz_enum.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 errors \u2502 \u251c\u2500\u2500 anchor.py \u2502 \u251c\u2500\u2500 custom.py \u2502 \u2514\u2500\u2500 __init__.py \u2514\u2500\u2500 program_id.py","title":"Example"},{"location":"clientgen/#using-the-generated-client","text":"","title":"Using the generated client"},{"location":"clientgen/#instructions","text":"from solders.hash import Hash from solders.keypair import Keypair from solders.message import Message from solders.pubkey import Pubkey from solders.transaction import Transaction from anchorpy import Provider from my_client.instructions import some_instruction # call an instruction foo_account = Keypair () # in real use, fetch this from an RPC recent_blockhash = Hash . default () ix = some_instruction ({ \"foo_param\" : \"...\" , \"bar_param\" : \"...\" , ... }, { \"foo_account\" : foo_account . pubkey (), # signer \"bar_account\" : Pubkey ( \"...\" ), ... }) msg = Message ( instructions = [ instruction ], payer = payer . pubkey ()) tx = Transaction ([ payer ], msg , recent_blockhash ) provider = Provider . local () await provider . send ( tx )","title":"Instructions"},{"location":"clientgen/#accounts","text":"from solders.pubkey import Pubkey from my_client.accounts import FooAccount # fetch an account addr = Pubkey ( \"...\" ) acc = await FooAccount . fetch ( connection , addr ) if acc is None : # the fetch method returns null when the account is uninitialized raise ValueError ( \"account not found\" ) # convert to a JSON object obj = acc . to_json () print ( obj ) # load from JSON acc_from_json = FooAccount . from_json ( obj )","title":"Accounts"},{"location":"clientgen/#types","text":"# structs from my_client.types import BarStruct bar_struct = BarStruct ( some_field = \"...\" , other_field = \"...\" , ) print ( bar_struct . to_json ()) # enums from my_client.types import baz_enum tuple_enum = baz_enum . SomeTupleKind (( True , False , \"some value\" )) struct_enum = baz_enum . SomeStructKind ({ \"field1\" : \"...\" , \"field2\" : \"...\" , }) disc_enum = baz_enum . SomeDiscriminantKind () print ( tuple_enum . toJSON (), struct_enum . toJSON (), disc_enum . toJSON ()) # types are used as arguments in instruction calls (where needed): ix = some_instruction ({ \"some_struct_field\" : bar_struct , \"some_enum_field\" : tuple_enum , # ... }, { # accounts # ... }) # in case of struct fields, it's also possible to pass them as objects: ix = some_instruction ({ \"some_struct_field\" : { \"some_field\" : \"...\" , \"other_field\" : \"...\" , }, # ..., }, { # accounts # ... })","title":"Types"},{"location":"clientgen/#errors","text":"from solana.rpc.core import RPCException from my_client.errors import from_tx_error from my_client.errors.custom import SomeCustomError try : await provider . send ( tx , [ payer ]) except RPCException as exc : parsed = from_tx_error ( exc ) raise parsed from exc","title":"Errors"},{"location":"clientgen/#program-id","text":"The client generator pulls the program ID from: the input IDL the --program-id flag If the IDL doesn't contain the program ID then you will need to pass it via the --program-id flag. This program ID is then written into the program_id.py file.","title":"Program ID"},{"location":"dynamic_client/","text":"Tutorial Note It is recommended to use the generated client instead of the dynamic client where possible, as it is easier to work with and comes with proper type hints. This tutorial takes the JS snippets from the official Anchor tutorial and shows how to achieve the same thing using AnchorPy. A Minimal Example This section covers the basic-0 tutorial: Generating a Client Here is how we generate a client from an IDL and use it to interact with a smart contract. Python JS from pathlib import Path import asyncio import json from solders.pubkey import Pubkey from anchorpy import Idl , Program async def main (): # Read the generated IDL. with Path ( \"target/idl/basic_0.json\" ) . open () as f : raw_idl = f . read () idl = Idl . from_json ( raw_idl ) # Address of the deployed program. program_id = Pubkey . from_string ( \"<YOUR-PROGRAM-ID>\" ) # Generate the program client from IDL. async with Program ( idl , program_id ) as program : # Execute the RPC. await program . rpc [ \"initialize\" ]() # If we don't use the context manager, we need to # close the underlying http client, otherwise we get warnings. # await program.close() asyncio . run ( main ()) // Read the generated IDL. const idl = JSON . parse ( require ( 'fs' ). readFileSync ( './target/idl/basic_0.json' , 'utf8' )); // Address of the deployed program. const programId = new anchor . web3 . Pubkey ( '<YOUR-PROGRAM-ID>' ); // Generate the program client from IDL. const program = new anchor . Program ( idl , programId ); // Execute the RPC. await program . rpc . initialize (); Note the differences between Python and JS here: We call program.rpc[\"initialize\"]() instead of program.rpc.initialize() We call program.close() to close the HTTP connection. Workspaces Here is how workspaces look in AnchorPy: Python JS import asyncio from anchorpy import create_workspace , close_workspace async def main (): # Read the deployed program from the workspace. workspace = create_workspace () program = workspace [ \"basic_0\" ] # Execute the RPC. await program . rpc [ \"initialize\" ]() # Close all HTTP clients in the workspace, otherwise we get warnings. await close_workspace ( workspace ) asyncio . run ( main ()) // Read the deployed program from the workspace. const program = anchor . workspace . Basic0 ; // Execute the RPC. await program . rpc . initialize (); Note the differences between Python and JS: Workspace instantiation is explicit: we have to call the create_workspace function. Note however that AnchorPy provides the workspace_fixture factory for convenience. See the testing section for more. We have a close_workspace function that calls close_program on all the programs in the workspace. The workspace is called basic_0 instead of Basic0 . This is because AnchorPy uses snake case \ud83d\udc0d Note AnchorPy uses the same case convention as Rust, so names should look just like they do in lib.rs . If you're unsure of a name, check program.idl : it shows how AnchorPy sees the IDL after parsing it and converting some cases. Arguments and Accounts Creating and Initializing Accounts Here is how we call an RPC function with arguments. As in the main Anchor tutorial, we will use anchor/tutorial/examples/basic-1 : Python JS import asyncio from solders.keypair import Keypair from solders.system_program import ID as SYS_PROGRAM_ID from anchorpy import create_workspace , close_workspace , Context async def main (): # Read the deployed program from the workspace. workspace = create_workspace () # The program to execute. program = workspace [ \"basic_1\" ] # The Account to create. my_account = Keypair () # Execute the RPC. accounts = { \"my_account\" : my_account . pubkey (), \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID } await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = accounts , signers = [ my_account ])) # Close all HTTP clients in the workspace, otherwise we get warnings. await close_workspace ( workspace ) asyncio . run ( main ()) // The program to execute. const program = anchor . workspace . Basic1 ; // The Account to create. const myAccount = anchor . web3 . Keypair (); // Create the new account and initialize it with the program. await program . rpc . initialize ( new anchor . BN ( 1234 ), { accounts : { myAccount : myAccount . Pubkey , user : provider . wallet . Pubkey , systemProgram : SystemProgram . programId , }, signers : [ myAccount ], }); Note how AnchorPy uses an explicit Context object in contrast to TS/JS.","title":"Tutorial"},{"location":"dynamic_client/#tutorial","text":"Note It is recommended to use the generated client instead of the dynamic client where possible, as it is easier to work with and comes with proper type hints. This tutorial takes the JS snippets from the official Anchor tutorial and shows how to achieve the same thing using AnchorPy.","title":"Tutorial"},{"location":"dynamic_client/#a-minimal-example","text":"This section covers the basic-0 tutorial:","title":"A Minimal Example"},{"location":"dynamic_client/#generating-a-client","text":"Here is how we generate a client from an IDL and use it to interact with a smart contract. Python JS from pathlib import Path import asyncio import json from solders.pubkey import Pubkey from anchorpy import Idl , Program async def main (): # Read the generated IDL. with Path ( \"target/idl/basic_0.json\" ) . open () as f : raw_idl = f . read () idl = Idl . from_json ( raw_idl ) # Address of the deployed program. program_id = Pubkey . from_string ( \"<YOUR-PROGRAM-ID>\" ) # Generate the program client from IDL. async with Program ( idl , program_id ) as program : # Execute the RPC. await program . rpc [ \"initialize\" ]() # If we don't use the context manager, we need to # close the underlying http client, otherwise we get warnings. # await program.close() asyncio . run ( main ()) // Read the generated IDL. const idl = JSON . parse ( require ( 'fs' ). readFileSync ( './target/idl/basic_0.json' , 'utf8' )); // Address of the deployed program. const programId = new anchor . web3 . Pubkey ( '<YOUR-PROGRAM-ID>' ); // Generate the program client from IDL. const program = new anchor . Program ( idl , programId ); // Execute the RPC. await program . rpc . initialize (); Note the differences between Python and JS here: We call program.rpc[\"initialize\"]() instead of program.rpc.initialize() We call program.close() to close the HTTP connection.","title":"Generating a Client"},{"location":"dynamic_client/#workspaces","text":"Here is how workspaces look in AnchorPy: Python JS import asyncio from anchorpy import create_workspace , close_workspace async def main (): # Read the deployed program from the workspace. workspace = create_workspace () program = workspace [ \"basic_0\" ] # Execute the RPC. await program . rpc [ \"initialize\" ]() # Close all HTTP clients in the workspace, otherwise we get warnings. await close_workspace ( workspace ) asyncio . run ( main ()) // Read the deployed program from the workspace. const program = anchor . workspace . Basic0 ; // Execute the RPC. await program . rpc . initialize (); Note the differences between Python and JS: Workspace instantiation is explicit: we have to call the create_workspace function. Note however that AnchorPy provides the workspace_fixture factory for convenience. See the testing section for more. We have a close_workspace function that calls close_program on all the programs in the workspace. The workspace is called basic_0 instead of Basic0 . This is because AnchorPy uses snake case \ud83d\udc0d Note AnchorPy uses the same case convention as Rust, so names should look just like they do in lib.rs . If you're unsure of a name, check program.idl : it shows how AnchorPy sees the IDL after parsing it and converting some cases.","title":"Workspaces"},{"location":"dynamic_client/#arguments-and-accounts","text":"","title":"Arguments and Accounts"},{"location":"dynamic_client/#creating-and-initializing-accounts","text":"Here is how we call an RPC function with arguments. As in the main Anchor tutorial, we will use anchor/tutorial/examples/basic-1 : Python JS import asyncio from solders.keypair import Keypair from solders.system_program import ID as SYS_PROGRAM_ID from anchorpy import create_workspace , close_workspace , Context async def main (): # Read the deployed program from the workspace. workspace = create_workspace () # The program to execute. program = workspace [ \"basic_1\" ] # The Account to create. my_account = Keypair () # Execute the RPC. accounts = { \"my_account\" : my_account . pubkey (), \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID } await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = accounts , signers = [ my_account ])) # Close all HTTP clients in the workspace, otherwise we get warnings. await close_workspace ( workspace ) asyncio . run ( main ()) // The program to execute. const program = anchor . workspace . Basic1 ; // The Account to create. const myAccount = anchor . web3 . Keypair (); // Create the new account and initialize it with the program. await program . rpc . initialize ( new anchor . BN ( 1234 ), { accounts : { myAccount : myAccount . Pubkey , user : provider . wallet . Pubkey , systemProgram : SystemProgram . programId , }, signers : [ myAccount ], }); Note how AnchorPy uses an explicit Context object in contrast to TS/JS.","title":"Creating and Initializing Accounts"},{"location":"dynamic_client/api_reference/","text":"API Reference Program Program provides the IDL deserialized client representation of an Anchor program. This API is the one stop shop for all things related to communicating with on-chain programs. Among other things, one can send transactions, fetch deserialized accounts, decode instruction data, subscribe to account changes, and listen to events. In addition to field accessors and methods, the object provides a set of dynamically generated properties, also known as namespaces, that map one-to-one to program methods and accounts. Source code in anchorpy/program/core.py class Program ( object ): \"\"\"Program provides the IDL deserialized client representation of an Anchor program. This API is the one stop shop for all things related to communicating with on-chain programs. Among other things, one can send transactions, fetch deserialized accounts, decode instruction data, subscribe to account changes, and listen to events. In addition to field accessors and methods, the object provides a set of dynamically generated properties, also known as namespaces, that map one-to-one to program methods and accounts. \"\"\" def __init__ ( self , idl : Idl , program_id : Pubkey , provider : Optional [ Provider ] = None ): \"\"\"Initialize the Program object. Args: idl: The parsed IDL object. program_id: The program ID. provider: The Provider object for the Program. Defaults to Provider.local(). \"\"\" self . idl = idl self . program_id = program_id self . provider = provider if provider is not None else Provider . local () self . coder = Coder ( idl ) ( rpc , instruction , transaction , account , simulate , types , methods , ) = _build_namespace ( idl , self . coder , program_id , self . provider , ) self . rpc = rpc self . instruction = instruction self . transaction = transaction self . account = account self . simulate = simulate self . type = types self . methods = methods async def __aenter__ ( self ) -> Program : \"\"\"Use as a context manager.\"\"\" await self . provider . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exit the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . provider . close () @staticmethod async def fetch_raw_idl ( address : AddressType , provider : Provider , ) -> str : \"\"\"Fetch an idl from the blockchain as a raw JSON dictionary. Args: address: The program ID. provider: The network and wallet context. Raises: IdlNotFoundError: If the requested IDL account does not exist. Returns: str: The raw IDL. \"\"\" program_id = translate_address ( address ) actual_provider = provider if provider is not None else Provider . local () idl_addr = _idl_address ( program_id ) account_info = await actual_provider . connection . get_account_info ( idl_addr ) account_info_val = account_info . value if account_info_val is None : raise IdlNotFoundError ( f \"IDL not found for program: { address } \" ) idl_account = _decode_idl_account ( account_info_val . data [ ACCOUNT_DISCRIMINATOR_SIZE :] ) return _pako_inflate ( bytes ( idl_account [ \"data\" ])) . decode () @classmethod async def fetch_idl ( cls , address : AddressType , provider : Provider , ) -> Idl : \"\"\"Fetch and parse an idl from the blockchain. Args: address: The program ID. provider: The network and wallet context. Returns: Idl: The fetched IDL. \"\"\" raw = await cls . fetch_raw_idl ( address , provider ) return Idl . from_json ( raw ) @classmethod async def at ( cls , address : AddressType , provider : Optional [ Provider ] = None , ) -> Program : \"\"\"Generate a Program client by fetching the IDL from the network. In order to use this method, an IDL must have been previously initialized via the anchor CLI's `anchor idl init` command. Args: address: The program ID. provider: The network and wallet context. Returns: The Program instantiated using the fetched IDL. \"\"\" provider_to_use = Provider . local () if provider is None else provider program_id = translate_address ( address ) idl = await cls . fetch_idl ( program_id , provider_to_use ) return cls ( idl , program_id , provider ) __init__ ( self , idl , program_id , provider = None ) special Initialize the Program object. Parameters: Name Type Description Default idl Idl The parsed IDL object. required program_id Pubkey The program ID. required provider Optional[Provider] The Provider object for the Program. Defaults to Provider.local(). None Source code in anchorpy/program/core.py def __init__ ( self , idl : Idl , program_id : Pubkey , provider : Optional [ Provider ] = None ): \"\"\"Initialize the Program object. Args: idl: The parsed IDL object. program_id: The program ID. provider: The Provider object for the Program. Defaults to Provider.local(). \"\"\" self . idl = idl self . program_id = program_id self . provider = provider if provider is not None else Provider . local () self . coder = Coder ( idl ) ( rpc , instruction , transaction , account , simulate , types , methods , ) = _build_namespace ( idl , self . coder , program_id , self . provider , ) self . rpc = rpc self . instruction = instruction self . transaction = transaction self . account = account self . simulate = simulate self . type = types self . methods = methods at ( address , provider = None ) async classmethod Generate a Program client by fetching the IDL from the network. In order to use this method, an IDL must have been previously initialized via the anchor CLI's anchor idl init command. Parameters: Name Type Description Default address AddressType The program ID. required provider Optional[Provider] The network and wallet context. None Returns: Type Description Program The Program instantiated using the fetched IDL. Source code in anchorpy/program/core.py @classmethod async def at ( cls , address : AddressType , provider : Optional [ Provider ] = None , ) -> Program : \"\"\"Generate a Program client by fetching the IDL from the network. In order to use this method, an IDL must have been previously initialized via the anchor CLI's `anchor idl init` command. Args: address: The program ID. provider: The network and wallet context. Returns: The Program instantiated using the fetched IDL. \"\"\" provider_to_use = Provider . local () if provider is None else provider program_id = translate_address ( address ) idl = await cls . fetch_idl ( program_id , provider_to_use ) return cls ( idl , program_id , provider ) close ( self ) async Use this when you are done with the client. Source code in anchorpy/program/core.py async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . provider . close () fetch_idl ( address , provider ) async classmethod Fetch and parse an idl from the blockchain. Parameters: Name Type Description Default address AddressType The program ID. required provider Provider The network and wallet context. required Returns: Type Description Idl The fetched IDL. Source code in anchorpy/program/core.py @classmethod async def fetch_idl ( cls , address : AddressType , provider : Provider , ) -> Idl : \"\"\"Fetch and parse an idl from the blockchain. Args: address: The program ID. provider: The network and wallet context. Returns: Idl: The fetched IDL. \"\"\" raw = await cls . fetch_raw_idl ( address , provider ) return Idl . from_json ( raw ) fetch_raw_idl ( address , provider ) async staticmethod Fetch an idl from the blockchain as a raw JSON dictionary. Parameters: Name Type Description Default address AddressType The program ID. required provider Provider The network and wallet context. required Exceptions: Type Description IdlNotFoundError If the requested IDL account does not exist. Returns: Type Description str The raw IDL. Source code in anchorpy/program/core.py @staticmethod async def fetch_raw_idl ( address : AddressType , provider : Provider , ) -> str : \"\"\"Fetch an idl from the blockchain as a raw JSON dictionary. Args: address: The program ID. provider: The network and wallet context. Raises: IdlNotFoundError: If the requested IDL account does not exist. Returns: str: The raw IDL. \"\"\" program_id = translate_address ( address ) actual_provider = provider if provider is not None else Provider . local () idl_addr = _idl_address ( program_id ) account_info = await actual_provider . connection . get_account_info ( idl_addr ) account_info_val = account_info . value if account_info_val is None : raise IdlNotFoundError ( f \"IDL not found for program: { address } \" ) idl_account = _decode_idl_account ( account_info_val . data [ ACCOUNT_DISCRIMINATOR_SIZE :] ) return _pako_inflate ( bytes ( idl_account [ \"data\" ])) . decode () Provider The network and wallet context used to send transactions paid for and signed by the provider. Source code in anchorpy/provider.py class Provider : \"\"\"The network and wallet context used to send transactions paid for and signed by the provider.\"\"\" # noqa: E501 def __init__ ( self , connection : AsyncClient , wallet : Wallet , opts : types . TxOpts = DEFAULT_OPTIONS , ) -> None : \"\"\"Initialize the Provider. Args: connection: The cluster connection where the program is deployed. wallet: The wallet used to pay for and sign all transactions. opts: Transaction confirmation options to use by default. \"\"\" self . connection = connection self . wallet = wallet self . opts = opts @classmethod def local ( cls , url : Optional [ str ] = None , opts : types . TxOpts = DEFAULT_OPTIONS ) -> Provider : \"\"\"Create a `Provider` with a wallet read from the local filesystem. Args: url: The network cluster url. opts: The default transaction confirmation options. \"\"\" connection = AsyncClient ( url , opts . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , opts ) @classmethod def readonly ( cls , url : Optional [ str ] = None , opts : types . TxOpts = DEFAULT_OPTIONS ) -> Provider : \"\"\"Create a `Provider` that can only fetch data, not send transactions. Args: url: The network cluster url. opts: The default transaction confirmation options. \"\"\" connection = AsyncClient ( url , opts . preflight_commitment ) wallet = Wallet . dummy () return cls ( connection , wallet , opts ) @classmethod def env ( cls ) -> Provider : \"\"\"Create a `Provider` using the `ANCHOR_PROVIDER_URL` environment variable.\"\"\" url = environ [ \"ANCHOR_PROVIDER_URL\" ] options = DEFAULT_OPTIONS connection = AsyncClient ( url , options . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , options ) async def simulate ( self , tx : Union [ Transaction , VersionedTransaction ], opts : Optional [ types . TxOpts ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate the given transaction, returning emitted logs from execution. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction simulation result. \"\"\" if opts is None : opts = self . opts return await self . connection . simulate_transaction ( tx , sig_verify = True , commitment = opts . preflight_commitment ) async def send ( self , tx : Union [ Transaction , VersionedTransaction ], opts : Optional [ types . TxOpts ] = None , ) -> Signature : \"\"\"Send the given transaction, paid for and signed by the provider's wallet. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction signature from the RPC server. \"\"\" if opts is None : opts = self . opts raw = bytes ( tx ) resp = await self . connection . send_raw_transaction ( raw , opts = opts ) return resp . value async def send_all ( self , txs : Sequence [ Union [ Transaction , VersionedTransaction ]], opts : Optional [ types . TxOpts ] = None , ) -> list [ Signature ]: \"\"\"Similar to `send`, but for an array of transactions and signers. Args: txs: a list of transaction objects. opts: Transaction confirmation options. Returns: The transaction signatures from the RPC server. \"\"\" if opts is None : opts = self . opts sigs = [] for tx in txs : raw = bytes ( tx ) resp = await self . connection . send_raw_transaction ( raw , opts = opts ) sigs . append ( resp . value ) return sigs async def __aenter__ ( self ) -> Provider : \"\"\"Use as a context manager.\"\"\" await self . connection . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exit the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Use this when you are done with the connection.\"\"\" await self . connection . close () __init__ ( self , connection , wallet , opts = TxOpts ( skip_confirmation = False , skip_preflight = False , preflight_commitment = 'processed' , max_retries = None , last_valid_block_height = None )) special Initialize the Provider. Parameters: Name Type Description Default connection AsyncClient The cluster connection where the program is deployed. required wallet Wallet The wallet used to pay for and sign all transactions. required opts types.TxOpts Transaction confirmation options to use by default. TxOpts(skip_confirmation=False, skip_preflight=False, preflight_commitment='processed', max_retries=None, last_valid_block_height=None) Source code in anchorpy/provider.py def __init__ ( self , connection : AsyncClient , wallet : Wallet , opts : types . TxOpts = DEFAULT_OPTIONS , ) -> None : \"\"\"Initialize the Provider. Args: connection: The cluster connection where the program is deployed. wallet: The wallet used to pay for and sign all transactions. opts: Transaction confirmation options to use by default. \"\"\" self . connection = connection self . wallet = wallet self . opts = opts close ( self ) async Use this when you are done with the connection. Source code in anchorpy/provider.py async def close ( self ) -> None : \"\"\"Use this when you are done with the connection.\"\"\" await self . connection . close () env () classmethod Create a Provider using the ANCHOR_PROVIDER_URL environment variable. Source code in anchorpy/provider.py @classmethod def env ( cls ) -> Provider : \"\"\"Create a `Provider` using the `ANCHOR_PROVIDER_URL` environment variable.\"\"\" url = environ [ \"ANCHOR_PROVIDER_URL\" ] options = DEFAULT_OPTIONS connection = AsyncClient ( url , options . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , options ) local ( url = None , opts = TxOpts ( skip_confirmation = False , skip_preflight = False , preflight_commitment = 'processed' , max_retries = None , last_valid_block_height = None )) classmethod Create a Provider with a wallet read from the local filesystem. Parameters: Name Type Description Default url Optional[str] The network cluster url. None opts types.TxOpts The default transaction confirmation options. TxOpts(skip_confirmation=False, skip_preflight=False, preflight_commitment='processed', max_retries=None, last_valid_block_height=None) Source code in anchorpy/provider.py @classmethod def local ( cls , url : Optional [ str ] = None , opts : types . TxOpts = DEFAULT_OPTIONS ) -> Provider : \"\"\"Create a `Provider` with a wallet read from the local filesystem. Args: url: The network cluster url. opts: The default transaction confirmation options. \"\"\" connection = AsyncClient ( url , opts . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , opts ) readonly ( url = None , opts = TxOpts ( skip_confirmation = False , skip_preflight = False , preflight_commitment = 'processed' , max_retries = None , last_valid_block_height = None )) classmethod Create a Provider that can only fetch data, not send transactions. Parameters: Name Type Description Default url Optional[str] The network cluster url. None opts types.TxOpts The default transaction confirmation options. TxOpts(skip_confirmation=False, skip_preflight=False, preflight_commitment='processed', max_retries=None, last_valid_block_height=None) Source code in anchorpy/provider.py @classmethod def readonly ( cls , url : Optional [ str ] = None , opts : types . TxOpts = DEFAULT_OPTIONS ) -> Provider : \"\"\"Create a `Provider` that can only fetch data, not send transactions. Args: url: The network cluster url. opts: The default transaction confirmation options. \"\"\" connection = AsyncClient ( url , opts . preflight_commitment ) wallet = Wallet . dummy () return cls ( connection , wallet , opts ) send ( self , tx , opts = None ) async Send the given transaction, paid for and signed by the provider's wallet. Parameters: Name Type Description Default tx Union[Transaction, VersionedTransaction] The transaction to send. required signers The set of signers in addition to the provider wallet that will sign the transaction. required opts Optional[types.TxOpts] Transaction confirmation options. None Returns: Type Description Signature The transaction signature from the RPC server. Source code in anchorpy/provider.py async def send ( self , tx : Union [ Transaction , VersionedTransaction ], opts : Optional [ types . TxOpts ] = None , ) -> Signature : \"\"\"Send the given transaction, paid for and signed by the provider's wallet. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction signature from the RPC server. \"\"\" if opts is None : opts = self . opts raw = bytes ( tx ) resp = await self . connection . send_raw_transaction ( raw , opts = opts ) return resp . value send_all ( self , txs , opts = None ) async Similar to send , but for an array of transactions and signers. Parameters: Name Type Description Default txs Sequence[Union[Transaction, VersionedTransaction]] a list of transaction objects. required opts Optional[types.TxOpts] Transaction confirmation options. None Returns: Type Description list[Signature] The transaction signatures from the RPC server. Source code in anchorpy/provider.py async def send_all ( self , txs : Sequence [ Union [ Transaction , VersionedTransaction ]], opts : Optional [ types . TxOpts ] = None , ) -> list [ Signature ]: \"\"\"Similar to `send`, but for an array of transactions and signers. Args: txs: a list of transaction objects. opts: Transaction confirmation options. Returns: The transaction signatures from the RPC server. \"\"\" if opts is None : opts = self . opts sigs = [] for tx in txs : raw = bytes ( tx ) resp = await self . connection . send_raw_transaction ( raw , opts = opts ) sigs . append ( resp . value ) return sigs simulate ( self , tx , opts = None ) async Simulate the given transaction, returning emitted logs from execution. Parameters: Name Type Description Default tx Union[Transaction, VersionedTransaction] The transaction to send. required signers The set of signers in addition to the provider wallet that will sign the transaction. required opts Optional[types.TxOpts] Transaction confirmation options. None Returns: Type Description SimulateTransactionResp The transaction simulation result. Source code in anchorpy/provider.py async def simulate ( self , tx : Union [ Transaction , VersionedTransaction ], opts : Optional [ types . TxOpts ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate the given transaction, returning emitted logs from execution. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction simulation result. \"\"\" if opts is None : opts = self . opts return await self . connection . simulate_transaction ( tx , sig_verify = True , commitment = opts . preflight_commitment ) Context dataclass Context provides all non-argument inputs for generating Anchor transactions. Attributes: Name Type Description accounts Dict[str, Any] The accounts used in the instruction context. remaining_accounts List[solders.instruction.AccountMeta] All accounts to pass into an instruction after the main signers List[solders.keypair.Keypair] Accounts that must sign a given transaction. pre_instructions List[solders.instruction.Instruction] Instructions to run before a given method. Often this is used, for example to create accounts prior to executing a method. post_instructions List[solders.instruction.Instruction] Instructions to run after a given method. Often this is used, for example to close accounts prior to executing a method. options Optional[solana.rpc.types.TxOpts] Commitment parameters to use for a transaction. Source code in anchorpy/program/context.py @dataclass class Context : \"\"\"Context provides all non-argument inputs for generating Anchor transactions. Attributes: accounts: The accounts used in the instruction context. remaining_accounts: All accounts to pass into an instruction *after* the main `accounts`. This can be used for optional or otherwise unknown accounts. signers: Accounts that must sign a given transaction. pre_instructions: Instructions to run *before* a given method. Often this is used, for example to create accounts prior to executing a method. post_instructions: Instructions to run *after* a given method. Often this is used, for example to close accounts prior to executing a method. options: Commitment parameters to use for a transaction. \"\"\" # For some reason mkdocstrings doesn't understand the full type hint # here if we use list[Instruction] instead of typing.List. # Weirdly there are other places where it understands list[whatever]. accounts : Accounts = field ( default_factory = dict ) remaining_accounts : List [ AccountMeta ] = field ( default_factory = list ) signers : List [ Keypair ] = field ( default_factory = list ) pre_instructions : List [ Instruction ] = field ( default_factory = list ) post_instructions : List [ Instruction ] = field ( default_factory = list ) options : Optional [ TxOpts ] = None create_workspace ( path = None , url = None ) Get a workspace from the provided path to the project root. Parameters: Name Type Description Default path Union[pathlib._local.Path, str] The path to the project root. Defaults to the current working directory if omitted. None url Optional[str] The URL of the JSON RPC. Defaults to http://localhost:8899. None Returns: Type Description Dict[str, anchorpy.program.core.Program] Mapping of program name to Program object. Source code in anchorpy/workspace.py def create_workspace ( path : Optional [ Union [ Path , str ]] = None , url : Optional [ str ] = None ) -> WorkspaceType : \"\"\"Get a workspace from the provided path to the project root. Args: path: The path to the project root. Defaults to the current working directory if omitted. url: The URL of the JSON RPC. Defaults to http://localhost:8899. Returns: Mapping of program name to Program object. \"\"\" result = {} project_root = Path . cwd () if path is None else Path ( path ) idl_folder = project_root / \"target/idl\" localnet_programs : dict [ str , str ] = toml . load ( project_root / \"Anchor.toml\" )[ \"programs\" ][ \"localnet\" ] for file in idl_folder . iterdir (): raw = file . read_text () idl = Idl . from_json ( raw ) name = idl . name program_id = Pubkey . from_string ( localnet_programs [ name ]) program = Program ( idl , program_id , Provider . local ( url )) result [ idl . name ] = program return result close_workspace ( workspace ) async Close the HTTP clients of all the programs in the workspace. Parameters: Name Type Description Default workspace Dict[str, anchorpy.program.core.Program] The workspace to close. required Source code in anchorpy/workspace.py async def close_workspace ( workspace : WorkspaceType ) -> None : \"\"\"Close the HTTP clients of all the programs in the workspace. Args: workspace: The workspace to close. \"\"\" for program in workspace . values (): # could do this in a faster way but there's probably no point. await program . close () workspace_fixture ( path , scope = 'module' , timeout_seconds = 60 , build_cmd = None ) Create a fixture that sets up and tears down a localnet instance and returns a workspace dict. Equivalent to combining localnet_fixture , create_workspace and close_workspace . Parameters: Name Type Description Default path Union[pathlib._local.Path, str] Path to root of the Anchor project. required scope Literal['session', 'package', 'module', 'class', 'function'] Pytest fixture scope. 'module' timeout_seconds int Time to wait for Anchor localnet to start. 60 build_cmd Optional[str] Command to run before anchor localnet . Defaults to anchor build . None Returns: Type Description Callable A workspace fixture for use with pytest. Source code in anchorpy/pytest_plugin.py def workspace_fixture ( path : Union [ Path , str ], scope : _Scope = \"module\" , timeout_seconds : int = 60 , build_cmd : Optional [ str ] = None , ) -> Callable : \"\"\"Create a fixture that sets up and tears down a localnet instance and returns a workspace dict. Equivalent to combining `localnet_fixture`, `create_workspace` and `close_workspace`. Args: path: Path to root of the Anchor project. scope: Pytest fixture scope. timeout_seconds: Time to wait for Anchor localnet to start. build_cmd: Command to run before `anchor localnet`. Defaults to `anchor build`. Returns: A workspace fixture for use with pytest. \"\"\" # noqa: E501,D202 @async_fixture ( scope = scope ) async def _workspace_fixture ( _fixed_xprocess , ) -> AsyncGenerator [ dict [ str , Program ], None ]: class Starter ( ProcessStarter ): # startup pattern pattern = \"JSON RPC URL\" terminate_on_interrupt = True # command to start process args = [ \"anchor\" , \"localnet\" , \"--skip-build\" ] timeout = timeout_seconds popen_kwargs = { \"cwd\" : path , \"start_new_session\" : True , } max_read_lines = 1_000 # command to start process actual_build_cmd = \"anchor build\" if build_cmd is None else build_cmd subprocess . run ( actual_build_cmd , cwd = path , check = True , shell = True ) # ensure process is running _ = _fixed_xprocess . ensure ( \"localnet\" , Starter ) ws = create_workspace ( path ) yield ws await close_workspace ( ws ) # clean up whole process tree afterwards _fixed_xprocess . getinfo ( \"localnet\" ) . terminate () return _workspace_fixture localnet_fixture ( path , scope = 'module' , timeout_seconds = 60 , build_cmd = None ) Create a fixture that sets up and tears down a localnet instance with workspace programs deployed. Parameters: Name Type Description Default path Path Path to root of the Anchor project. required scope Literal['session', 'package', 'module', 'class', 'function'] Pytest fixture scope. 'module' timeout_seconds int Time to wait for Anchor localnet to start. 60 build_cmd Optional[str] Command to run before anchor localnet . Defaults to anchor build . None Returns: Type Description Callable A localnet fixture for use with pytest. Source code in anchorpy/pytest_plugin.py def localnet_fixture ( path : Path , scope : _Scope = \"module\" , timeout_seconds : int = 60 , build_cmd : Optional [ str ] = None , ) -> Callable : \"\"\"Create a fixture that sets up and tears down a localnet instance with workspace programs deployed. Args: path: Path to root of the Anchor project. scope: Pytest fixture scope. timeout_seconds: Time to wait for Anchor localnet to start. build_cmd: Command to run before `anchor localnet`. Defaults to `anchor build`. Returns: A localnet fixture for use with pytest. \"\"\" # noqa: E501,D202 @fixture ( scope = scope ) def _localnet_fixture ( _fixed_xprocess ): class Starter ( ProcessStarter ): # startup pattern pattern = \"JSON RPC URL\" terminate_on_interrupt = True # command to start process args = [ \"anchor\" , \"localnet\" , \"--skip-build\" ] timeout = timeout_seconds popen_kwargs = { \"cwd\" : path , \"start_new_session\" : True , } max_read_lines = 1_000 # command to start process actual_build_cmd = \"anchor build\" if build_cmd is None else build_cmd subprocess . run ( actual_build_cmd , cwd = path , check = True , shell = True ) # ensure process is running and return its logfile logfile = _fixed_xprocess . ensure ( \"localnet\" , Starter ) yield logfile # clean up whole process tree afterwards _fixed_xprocess . getinfo ( \"localnet\" ) . terminate () return _localnet_fixture Wallet Python wallet object. Source code in anchorpy/provider.py class Wallet : \"\"\"Python wallet object.\"\"\" def __init__ ( self , payer : Keypair ): \"\"\"Initialize the wallet. Args: payer: the Keypair used to sign transactions. \"\"\" self . payer = payer @property def public_key ( self ) -> Pubkey : \"\"\"Get the public key of the wallet.\"\"\" return self . payer . pubkey () def sign_transaction ( self , tx : Transaction ) -> Transaction : \"\"\"Sign a transaction using the wallet's keypair. Args: tx: The transaction to sign. Returns: The signed transaction. \"\"\" tx . sign ([ self . payer ], tx . message . recent_blockhash ) return tx def sign_all_transactions ( self , txs : list [ Transaction ]) -> list [ Transaction ]: \"\"\"Sign a list of transactions using the wallet's keypair. Args: txs: The transactions to sign. Returns: The signed transactions. \"\"\" for tx in txs : tx . partial_sign ([ self . payer ], tx . message . recent_blockhash ) return txs @classmethod def local ( cls ) -> Wallet : \"\"\"Create a wallet instance from the filesystem. Uses the path at the ANCHOR_WALLET env var if set, otherwise uses ~/.config/solana/id.json. \"\"\" path = Path ( getenv ( \"ANCHOR_WALLET\" , Path . home () / \".config/solana/id.json\" )) with path . open () as f : keypair : List [ int ] = json . load ( f ) return cls ( Keypair . from_bytes ( keypair )) @classmethod def dummy ( cls ) -> Wallet : \"\"\"Create a dummy wallet instance that won't be used to sign transactions.\"\"\" keypair = Keypair () return cls ( keypair ) public_key : Pubkey property readonly Get the public key of the wallet. __init__ ( self , payer ) special Initialize the wallet. Parameters: Name Type Description Default payer Keypair the Keypair used to sign transactions. required Source code in anchorpy/provider.py def __init__ ( self , payer : Keypair ): \"\"\"Initialize the wallet. Args: payer: the Keypair used to sign transactions. \"\"\" self . payer = payer dummy () classmethod Create a dummy wallet instance that won't be used to sign transactions. Source code in anchorpy/provider.py @classmethod def dummy ( cls ) -> Wallet : \"\"\"Create a dummy wallet instance that won't be used to sign transactions.\"\"\" keypair = Keypair () return cls ( keypair ) local () classmethod Create a wallet instance from the filesystem. Uses the path at the ANCHOR_WALLET env var if set, otherwise uses ~/.config/solana/id.json. Source code in anchorpy/provider.py @classmethod def local ( cls ) -> Wallet : \"\"\"Create a wallet instance from the filesystem. Uses the path at the ANCHOR_WALLET env var if set, otherwise uses ~/.config/solana/id.json. \"\"\" path = Path ( getenv ( \"ANCHOR_WALLET\" , Path . home () / \".config/solana/id.json\" )) with path . open () as f : keypair : List [ int ] = json . load ( f ) return cls ( Keypair . from_bytes ( keypair )) sign_all_transactions ( self , txs ) Sign a list of transactions using the wallet's keypair. Parameters: Name Type Description Default txs list[Transaction] The transactions to sign. required Returns: Type Description list[Transaction] The signed transactions. Source code in anchorpy/provider.py def sign_all_transactions ( self , txs : list [ Transaction ]) -> list [ Transaction ]: \"\"\"Sign a list of transactions using the wallet's keypair. Args: txs: The transactions to sign. Returns: The signed transactions. \"\"\" for tx in txs : tx . partial_sign ([ self . payer ], tx . message . recent_blockhash ) return txs sign_transaction ( self , tx ) Sign a transaction using the wallet's keypair. Parameters: Name Type Description Default tx Transaction The transaction to sign. required Returns: Type Description Transaction The signed transaction. Source code in anchorpy/provider.py def sign_transaction ( self , tx : Transaction ) -> Transaction : \"\"\"Sign a transaction using the wallet's keypair. Args: tx: The transaction to sign. Returns: The signed transaction. \"\"\" tx . sign ([ self . payer ], tx . message . recent_blockhash ) return tx Coder Coder provides a facade for encoding and decoding all IDL related objects. Source code in anchorpy/coder/coder.py class Coder : \"\"\"Coder provides a facade for encoding and decoding all IDL related objects.\"\"\" def __init__ ( self , idl : Idl ): \"\"\"Initialize the coder. Args: idl: a parsed Idl instance. \"\"\" self . instruction : InstructionCoder = InstructionCoder ( idl ) self . accounts : AccountsCoder = AccountsCoder ( idl ) self . events : EventCoder = EventCoder ( idl ) self . types : TypesCoder = TypesCoder ( idl ) __init__ ( self , idl ) special Initialize the coder. Parameters: Name Type Description Default idl Idl a parsed Idl instance. required Source code in anchorpy/coder/coder.py def __init__ ( self , idl : Idl ): \"\"\"Initialize the coder. Args: idl: a parsed Idl instance. \"\"\" self . instruction : InstructionCoder = InstructionCoder ( idl ) self . accounts : AccountsCoder = AccountsCoder ( idl ) self . events : EventCoder = EventCoder ( idl ) self . types : TypesCoder = TypesCoder ( idl ) InstructionCoder ( Adapter ) Encodes and decodes program instructions. Source code in anchorpy/coder/instruction.py class InstructionCoder ( Adapter ): \"\"\"Encodes and decodes program instructions.\"\"\" def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . ix_layout = _parse_ix_layout ( idl ) sighasher = _Sighash () sighash_layouts : Dict [ bytes , Construct ] = {} sighashes : Dict [ str , bytes ] = {} sighash_to_name : Dict [ bytes , str ] = {} for ix in idl . instructions : ix_name = snake ( ix . name ) sh = sighasher . build ( ix_name ) sighashes [ ix_name ] = sh sighash_layouts [ sh ] = self . ix_layout [ ix_name ] sighash_to_name [ sh ] = ix_name self . sighash_layouts = sighash_layouts self . sighashes = sighashes self . sighash_to_name = sighash_to_name subcon = Sequence ( \"sighash\" / Bytes ( 8 ), Switch ( lambda this : this . sighash , sighash_layouts ), ) super () . __init__ ( subcon ) # type: ignore def encode ( self , ix_name : str , ix : Dict [ str , Any ]) -> bytes : \"\"\"Encode a program instruction. Args: ix_name: The name of the instruction ix: The data to encode. Returns: The encoded instruction. \"\"\" return self . build ( NamedInstruction ( name = ix_name , data = ix )) def _decode ( self , obj : Tuple [ bytes , Any ], context , path ) -> NamedInstruction : return NamedInstruction ( data = obj [ 1 ], name = self . sighash_to_name [ obj [ 0 ]]) def _encode ( self , obj : NamedInstruction , context : Container , path ) -> Tuple [ bytes , Any ]: return ( self . sighashes [ obj . name ], obj . data ) __init__ ( self , idl ) special Init. Parameters: Name Type Description Default idl Idl The parsed IDL object. required Source code in anchorpy/coder/instruction.py def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . ix_layout = _parse_ix_layout ( idl ) sighasher = _Sighash () sighash_layouts : Dict [ bytes , Construct ] = {} sighashes : Dict [ str , bytes ] = {} sighash_to_name : Dict [ bytes , str ] = {} for ix in idl . instructions : ix_name = snake ( ix . name ) sh = sighasher . build ( ix_name ) sighashes [ ix_name ] = sh sighash_layouts [ sh ] = self . ix_layout [ ix_name ] sighash_to_name [ sh ] = ix_name self . sighash_layouts = sighash_layouts self . sighashes = sighashes self . sighash_to_name = sighash_to_name subcon = Sequence ( \"sighash\" / Bytes ( 8 ), Switch ( lambda this : this . sighash , sighash_layouts ), ) super () . __init__ ( subcon ) # type: ignore encode ( self , ix_name , ix ) Encode a program instruction. Parameters: Name Type Description Default ix_name str The name of the instruction required ix Dict[str, Any] The data to encode. required Returns: Type Description bytes The encoded instruction. Source code in anchorpy/coder/instruction.py def encode ( self , ix_name : str , ix : Dict [ str , Any ]) -> bytes : \"\"\"Encode a program instruction. Args: ix_name: The name of the instruction ix: The data to encode. Returns: The encoded instruction. \"\"\" return self . build ( NamedInstruction ( name = ix_name , data = ix )) EventCoder ( Adapter ) Encodes and decodes Anchor events. Source code in anchorpy/coder/event.py class EventCoder ( Adapter ): \"\"\"Encodes and decodes Anchor events.\"\"\" def __init__ ( self , idl : Idl ): \"\"\"Initialize the EventCoder. Args: idl: The parsed Idl object. \"\"\" self . idl = idl idl_events = idl . events layouts : Dict [ str , Construct ] if idl_events : layouts = { event . name : _event_layout ( event , idl ) for event in idl_events } else : layouts = {} self . layouts = layouts self . discriminators : Dict [ bytes , str ] = ( {} if idl_events is None else { _event_discriminator ( event . name ): event . name for event in idl_events } ) self . discriminator_to_layout = { disc : self . layouts [ event_name ] for disc , event_name in self . discriminators . items () } subcon = Sequence ( \"discriminator\" / Bytes ( 8 ), # not base64-encoded here Switch ( lambda this : this . discriminator , self . discriminator_to_layout ), ) super () . __init__ ( subcon ) # type: ignore def _decode ( self , obj : Tuple [ bytes , Any ], context , path ) -> Optional [ Event ]: disc = obj [ 0 ] try : event_name = self . discriminators [ disc ] except KeyError : return None return Event ( data = obj [ 1 ], name = event_name ) __init__ ( self , idl ) special Initialize the EventCoder. Parameters: Name Type Description Default idl Idl The parsed Idl object. required Source code in anchorpy/coder/event.py def __init__ ( self , idl : Idl ): \"\"\"Initialize the EventCoder. Args: idl: The parsed Idl object. \"\"\" self . idl = idl idl_events = idl . events layouts : Dict [ str , Construct ] if idl_events : layouts = { event . name : _event_layout ( event , idl ) for event in idl_events } else : layouts = {} self . layouts = layouts self . discriminators : Dict [ bytes , str ] = ( {} if idl_events is None else { _event_discriminator ( event . name ): event . name for event in idl_events } ) self . discriminator_to_layout = { disc : self . layouts [ event_name ] for disc , event_name in self . discriminators . items () } subcon = Sequence ( \"discriminator\" / Bytes ( 8 ), # not base64-encoded here Switch ( lambda this : this . discriminator , self . discriminator_to_layout ), ) super () . __init__ ( subcon ) # type: ignore AccountsCoder ( Adapter ) Encodes and decodes account data. Source code in anchorpy/coder/accounts.py class AccountsCoder ( Adapter ): \"\"\"Encodes and decodes account data.\"\"\" def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . _accounts_layout = { acc . name : _typedef_layout ( acc , idl . types , acc . name ) for acc in idl . accounts } self . acc_name_to_discriminator = { acc . name : _account_discriminator ( acc . name ) for acc in idl . accounts } self . discriminator_to_acc_name = { disc : acc_name for acc_name , disc in self . acc_name_to_discriminator . items () } discriminator_to_typedef_layout = { disc : self . _accounts_layout [ acc_name ] for acc_name , disc in self . acc_name_to_discriminator . items () } subcon = Sequence ( \"discriminator\" / Bytes ( ACCOUNT_DISCRIMINATOR_SIZE ), Switch ( lambda this : this . discriminator , discriminator_to_typedef_layout ), ) super () . __init__ ( subcon ) # type: ignore def decode ( self , obj : bytes ) -> Container [ Any ]: \"\"\"Decode account data. Args: obj: Data to decode. Returns: Decoded data. \"\"\" return self . parse ( obj ) . data def _decode ( self , obj : Tuple [ bytes , Any ], context , path ) -> AccountToSerialize : return AccountToSerialize ( data = obj [ 1 ], name = self . discriminator_to_acc_name [ obj [ 0 ]], ) def _encode ( self , obj : AccountToSerialize , context , path ) -> Tuple [ bytes , Any ]: discriminator = self . acc_name_to_discriminator [ obj . name ] return discriminator , obj . data __init__ ( self , idl ) special Init. Parameters: Name Type Description Default idl Idl The parsed IDL object. required Source code in anchorpy/coder/accounts.py def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . _accounts_layout = { acc . name : _typedef_layout ( acc , idl . types , acc . name ) for acc in idl . accounts } self . acc_name_to_discriminator = { acc . name : _account_discriminator ( acc . name ) for acc in idl . accounts } self . discriminator_to_acc_name = { disc : acc_name for acc_name , disc in self . acc_name_to_discriminator . items () } discriminator_to_typedef_layout = { disc : self . _accounts_layout [ acc_name ] for acc_name , disc in self . acc_name_to_discriminator . items () } subcon = Sequence ( \"discriminator\" / Bytes ( ACCOUNT_DISCRIMINATOR_SIZE ), Switch ( lambda this : this . discriminator , discriminator_to_typedef_layout ), ) super () . __init__ ( subcon ) # type: ignore decode ( self , obj ) Decode account data. Parameters: Name Type Description Default obj bytes Data to decode. required Returns: Type Description construct.lib.containers.Container[Any] Decoded data. Source code in anchorpy/coder/accounts.py def decode ( self , obj : bytes ) -> Container [ Any ]: \"\"\"Decode account data. Args: obj: Data to decode. Returns: Decoded data. \"\"\" return self . parse ( obj ) . data NamedInstruction dataclass Container for a named instruction. Attributes: Name Type Description data Union[Dict[str, Any], construct.lib.containers.Container[Any]] The actual instruction data. name str The name of the instruction. Source code in anchorpy/program/common.py @dataclass class NamedInstruction : \"\"\"Container for a named instruction. Attributes: data: The actual instruction data. name: The name of the instruction. \"\"\" data : Union [ Dict [ str , Any ], Container [ Any ]] name : str IdlProgramAccount ( dict ) The on-chain account of the IDL. Source code in anchorpy/idl.py class IdlProgramAccount ( TypedDict ): \"\"\"The on-chain account of the IDL.\"\"\" authority : solders . pubkey . Pubkey data : bytes Event ( tuple ) A parsed event object. Source code in anchorpy/program/common.py class Event ( NamedTuple ): \"\"\"A parsed event object.\"\"\" name : str data : Any translate_address ( address ) Convert str | Pubkey into Pubkey . Parameters: Name Type Description Default address Union[solders.pubkey.Pubkey, str] Public key as string or Pubkey . required Returns: Type Description Pubkey Public key as Pubkey . Source code in anchorpy/program/common.py def translate_address ( address : AddressType ) -> Pubkey : \"\"\"Convert `str | Pubkey` into `Pubkey`. Args: address: Public key as string or `Pubkey`. Returns: Public key as `Pubkey`. \"\"\" if isinstance ( address , str ): return Pubkey . from_string ( address ) return address validate_accounts ( ix_accounts , accounts ) Check that accounts passed in ctx match the IDL. Parameters: Name Type Description Default ix_accounts list[Union[anchorpy_core.idl.IdlAccount, anchorpy_core.idl.IdlAccounts]] Accounts from the IDL. required accounts Dict[str, Any] Accounts from the ctx arg. required Exceptions: Type Description ValueError If ctx accounts don't match the IDL. Source code in anchorpy/program/common.py def validate_accounts ( ix_accounts : list [ IdlAccountItem ], accounts : Accounts ): \"\"\"Check that accounts passed in `ctx` match the IDL. Args: ix_accounts: Accounts from the IDL. accounts: Accounts from the `ctx` arg. Raises: ValueError: If `ctx` accounts don't match the IDL. \"\"\" for acc in ix_accounts : acc_name = snake ( acc . name ) if isinstance ( acc , IdlAccounts ): nested = cast ( Accounts , accounts [ acc_name ]) validate_accounts ( acc . accounts , nested ) elif acc_name not in accounts : raise ValueError ( f \"Invalid arguments: { acc_name } not provided\" ) AccountClient Provides methods for fetching and creating accounts. Source code in anchorpy/program/namespace/account.py class AccountClient ( object ): \"\"\"Provides methods for fetching and creating accounts.\"\"\" def __init__ ( self , idl : Idl , idl_account : IdlTypeDefinition , coder : Coder , program_id : Pubkey , provider : Provider , ): \"\"\"Init. Args: idl: the parsed IDL object. idl_account: the account definition from the IDL. coder: The program's Coder object. program_id: the program ID. provider: The Provider object for the Program. \"\"\" self . _idl_account = idl_account self . _program_id = program_id self . _provider = provider self . _coder = coder self . _size = ACCOUNT_DISCRIMINATOR_SIZE + _account_size ( idl , idl_account ) async def fetch ( self , address : Pubkey , commitment : Optional [ Commitment ] = None ) -> Container [ Any ]: \"\"\"Return a deserialized account. Args: address: The address of the account to fetch. commitment: Bank state to query. Raises: AccountDoesNotExistError: If the account doesn't exist. AccountInvalidDiscriminator: If the discriminator doesn't match the IDL. \"\"\" account_info = await self . _provider . connection . get_account_info ( address , encoding = \"base64\" , commitment = commitment , ) if not account_info . value : raise AccountDoesNotExistError ( f \"Account { address } does not exist\" ) data = account_info . value . data discriminator = _account_discriminator ( self . _idl_account . name ) if discriminator != data [: ACCOUNT_DISCRIMINATOR_SIZE ]: msg = f \"Account { address } has an invalid discriminator\" raise AccountInvalidDiscriminator ( msg ) return self . _coder . accounts . decode ( data ) async def fetch_multiple ( self , addresses : List [ Pubkey ], batch_size : int = 300 , commitment : Optional [ Commitment ] = None , ) -> list [ Optional [ Container [ Any ]]]: \"\"\"Return multiple deserialized accounts. Accounts not found or with wrong discriminator are returned as None. Args: addresses: The addresses of the accounts to fetch. batch_size: The number of `getMultipleAccounts` objects to send in each HTTP request. commitment: Bank state to query. \"\"\" accounts = await get_multiple_accounts ( self . _provider . connection , addresses , batch_size = batch_size , commitment = commitment , ) discriminator = _account_discriminator ( self . _idl_account . name ) result : list [ Optional [ Container [ Any ]]] = [] for account in accounts : if account is None : result . append ( None ) elif discriminator == account . account . data [: 8 ]: result . append ( self . _coder . accounts . decode ( account . account . data )) else : result . append ( None ) return result async def create_instruction ( self , signer : Keypair , size_override : int = 0 , ) -> Instruction : \"\"\"Return an instruction for creating this account. Args: signer: [description] size_override: Optional override for the account size. Defaults to 0. Returns: The instruction to create the account. \"\"\" space = size_override if size_override else self . _size mbre_resp = ( await self . _provider . connection . get_minimum_balance_for_rent_exemption ( space ) ) return create_account ( CreateAccountParams ( from_pubkey = self . _provider . wallet . public_key , to_pubkey = signer . pubkey (), space = space , lamports = mbre_resp . value , owner = self . _program_id , ) ) async def all ( # noqa: A003 self , buffer : Optional [ bytes ] = None , filters : Optional [ List [ Union [ int , MemcmpOpts ]]] = None , ) -> list [ ProgramAccount ]: \"\"\"Return all instances of this account type for the program. Args: buffer: bytes filter to append to the discriminator. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" all_accounts = [] discriminator = _account_discriminator ( self . _idl_account . name ) to_encode = discriminator if buffer is None else discriminator + buffer bytes_arg = b58encode ( to_encode ) . decode ( \"ascii\" ) base_memcmp_opt = MemcmpOpts ( offset = 0 , bytes = bytes_arg , ) filters_to_use = [ base_memcmp_opt ] + ([] if filters is None else filters ) resp = await self . _provider . connection . get_program_accounts ( self . _program_id , encoding = \"base64\" , commitment = self . provider . connection . _commitment , filters = filters_to_use , ) for r in resp . value : account_data = r . account . data all_accounts . append ( ProgramAccount ( public_key = r . pubkey , account = self . _coder . accounts . decode ( account_data ), ), ) return all_accounts @property def size ( self ) -> int : \"\"\"Return the number of bytes in this account.\"\"\" return self . _size @property def program_id ( self ) -> Pubkey : \"\"\"Return the program ID owning all accounts.\"\"\" return self . _program_id @property def provider ( self ) -> Provider : \"\"\"Return the client's wallet and network provider.\"\"\" return self . _provider @property def coder ( self ) -> Coder : \"\"\"Return the coder.\"\"\" return self . _coder coder : Coder property readonly Return the coder. program_id : Pubkey property readonly Return the program ID owning all accounts. provider : Provider property readonly Return the client's wallet and network provider. size : int property readonly Return the number of bytes in this account. __init__ ( self , idl , idl_account , coder , program_id , provider ) special Init. Parameters: Name Type Description Default idl Idl the parsed IDL object. required idl_account IdlTypeDefinition the account definition from the IDL. required coder Coder The program's Coder object. required program_id Pubkey the program ID. required provider Provider The Provider object for the Program. required Source code in anchorpy/program/namespace/account.py def __init__ ( self , idl : Idl , idl_account : IdlTypeDefinition , coder : Coder , program_id : Pubkey , provider : Provider , ): \"\"\"Init. Args: idl: the parsed IDL object. idl_account: the account definition from the IDL. coder: The program's Coder object. program_id: the program ID. provider: The Provider object for the Program. \"\"\" self . _idl_account = idl_account self . _program_id = program_id self . _provider = provider self . _coder = coder self . _size = ACCOUNT_DISCRIMINATOR_SIZE + _account_size ( idl , idl_account ) all ( self , buffer = None , filters = None ) async Return all instances of this account type for the program. Parameters: Name Type Description Default buffer Optional[bytes] bytes filter to append to the discriminator. None filters Optional[List[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Source code in anchorpy/program/namespace/account.py async def all ( # noqa: A003 self , buffer : Optional [ bytes ] = None , filters : Optional [ List [ Union [ int , MemcmpOpts ]]] = None , ) -> list [ ProgramAccount ]: \"\"\"Return all instances of this account type for the program. Args: buffer: bytes filter to append to the discriminator. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" all_accounts = [] discriminator = _account_discriminator ( self . _idl_account . name ) to_encode = discriminator if buffer is None else discriminator + buffer bytes_arg = b58encode ( to_encode ) . decode ( \"ascii\" ) base_memcmp_opt = MemcmpOpts ( offset = 0 , bytes = bytes_arg , ) filters_to_use = [ base_memcmp_opt ] + ([] if filters is None else filters ) resp = await self . _provider . connection . get_program_accounts ( self . _program_id , encoding = \"base64\" , commitment = self . provider . connection . _commitment , filters = filters_to_use , ) for r in resp . value : account_data = r . account . data all_accounts . append ( ProgramAccount ( public_key = r . pubkey , account = self . _coder . accounts . decode ( account_data ), ), ) return all_accounts create_instruction ( self , signer , size_override = 0 ) async Return an instruction for creating this account. Parameters: Name Type Description Default signer Keypair [description] required size_override int Optional override for the account size. Defaults to 0. 0 Returns: Type Description Instruction The instruction to create the account. Source code in anchorpy/program/namespace/account.py async def create_instruction ( self , signer : Keypair , size_override : int = 0 , ) -> Instruction : \"\"\"Return an instruction for creating this account. Args: signer: [description] size_override: Optional override for the account size. Defaults to 0. Returns: The instruction to create the account. \"\"\" space = size_override if size_override else self . _size mbre_resp = ( await self . _provider . connection . get_minimum_balance_for_rent_exemption ( space ) ) return create_account ( CreateAccountParams ( from_pubkey = self . _provider . wallet . public_key , to_pubkey = signer . pubkey (), space = space , lamports = mbre_resp . value , owner = self . _program_id , ) ) fetch ( self , address , commitment = None ) async Return a deserialized account. Parameters: Name Type Description Default address Pubkey The address of the account to fetch. required commitment Optional[solana.rpc.commitment.Commitment] Bank state to query. None Exceptions: Type Description AccountDoesNotExistError If the account doesn't exist. AccountInvalidDiscriminator If the discriminator doesn't match the IDL. Source code in anchorpy/program/namespace/account.py async def fetch ( self , address : Pubkey , commitment : Optional [ Commitment ] = None ) -> Container [ Any ]: \"\"\"Return a deserialized account. Args: address: The address of the account to fetch. commitment: Bank state to query. Raises: AccountDoesNotExistError: If the account doesn't exist. AccountInvalidDiscriminator: If the discriminator doesn't match the IDL. \"\"\" account_info = await self . _provider . connection . get_account_info ( address , encoding = \"base64\" , commitment = commitment , ) if not account_info . value : raise AccountDoesNotExistError ( f \"Account { address } does not exist\" ) data = account_info . value . data discriminator = _account_discriminator ( self . _idl_account . name ) if discriminator != data [: ACCOUNT_DISCRIMINATOR_SIZE ]: msg = f \"Account { address } has an invalid discriminator\" raise AccountInvalidDiscriminator ( msg ) return self . _coder . accounts . decode ( data ) fetch_multiple ( self , addresses , batch_size = 300 , commitment = None ) async Return multiple deserialized accounts. Accounts not found or with wrong discriminator are returned as None. Parameters: Name Type Description Default addresses List[solders.pubkey.Pubkey] The addresses of the accounts to fetch. required batch_size int The number of getMultipleAccounts objects to send in each HTTP request. 300 commitment Optional[solana.rpc.commitment.Commitment] Bank state to query. None Source code in anchorpy/program/namespace/account.py async def fetch_multiple ( self , addresses : List [ Pubkey ], batch_size : int = 300 , commitment : Optional [ Commitment ] = None , ) -> list [ Optional [ Container [ Any ]]]: \"\"\"Return multiple deserialized accounts. Accounts not found or with wrong discriminator are returned as None. Args: addresses: The addresses of the accounts to fetch. batch_size: The number of `getMultipleAccounts` objects to send in each HTTP request. commitment: Bank state to query. \"\"\" accounts = await get_multiple_accounts ( self . _provider . connection , addresses , batch_size = batch_size , commitment = commitment , ) discriminator = _account_discriminator ( self . _idl_account . name ) result : list [ Optional [ Container [ Any ]]] = [] for account in accounts : if account is None : result . append ( None ) elif discriminator == account . account . data [: 8 ]: result . append ( self . _coder . accounts . decode ( account . account . data )) else : result . append ( None ) return result ProgramAccount dataclass Deserialized account owned by a program. Source code in anchorpy/program/namespace/account.py @dataclass class ProgramAccount : \"\"\"Deserialized account owned by a program.\"\"\" public_key : Pubkey account : Container EventParser dataclass Parser to handle on_logs callbacks. Source code in anchorpy/program/event.py @dataclass class EventParser : \"\"\"Parser to handle on_logs callbacks.\"\"\" program_id : Pubkey coder : Coder def parse_logs ( self , logs : List [ str ], callback : Callable [[ Event ], None ]) -> None : \"\"\"Parse a list of logs using a provided callback. Args: logs: The logs to parse. callback: The function to handle the parsed log. \"\"\" log_scanner = _LogScanner ( logs ) execution = _ExecutionContext ( cast ( str , log_scanner . to_next ())) log = log_scanner . to_next () while log is not None : event , new_program , did_pop = self . handle_log ( execution , log ) if event is not None : callback ( event ) if new_program is not None : execution . push ( new_program ) if did_pop : execution . pop () log = log_scanner . to_next () def handle_log ( self , execution : _ExecutionContext , log : str , ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Main log handler. Args: execution: The execution stack. log: log string from the RPC node. Returns: A three element array of the event, the next program that was invoked for CPI, and a boolean indicating if a program has completed execution (and thus should be popped off the execution stack). \"\"\" # Executing program is this program. if execution . stack and execution . program () == str ( self . program_id ): return self . handle_program_log ( log ) # Executing program is not this program. return ( None , * self . handle_system_log ( log )) def handle_program_log ( self , log : str ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Handle logs from *this* program. Args: log: log string from the RPC node. \"\"\" # This is a `msg!` log or a `sol_log_data!` log. if log . startswith ( PROGRAM_LOG ) or log . startswith ( PROGRAM_DATA ): log_str = ( log [ PROGRAM_LOG_START_INDEX :] if log . startswith ( PROGRAM_LOG ) else log [ PROGRAM_DATA_START_INDEX :] ) try : decoded = b64decode ( log_str ) except binascii . Error : return None , None , False event = self . coder . events . parse ( decoded ) return event , None , False return ( None , * self . handle_system_log ( log )) def handle_system_log ( self , log : str ) -> tuple [ Optional [ str ], bool ]: \"\"\"Handle logs when the current program being executing is *not* this. Args: log: log string from the RPC node. \"\"\" log_start = log . split ( \":\" )[ 0 ] splitted = log_start . split ( \" \" ) invoke_msg = f \"Program { str ( self . program_id ) } invoke\" if len ( splitted ) == 3 and splitted [ 0 ] == \"Program\" and splitted [ 2 ] == \"success\" : return None , True if log_start . startswith ( invoke_msg ): return str ( self . program_id ), False if \"invoke\" in log_start : return \"cpi\" , False return None , False handle_log ( self , execution , log ) Main log handler. Parameters: Name Type Description Default execution _ExecutionContext The execution stack. required log str log string from the RPC node. required Returns: Type Description tuple[Optional[anchorpy.program.common.Event], Optional[str], bool] A three element array of the event, the next program that was invoked for CPI, and a boolean indicating if a program has completed execution (and thus should be popped off the execution stack). Source code in anchorpy/program/event.py def handle_log ( self , execution : _ExecutionContext , log : str , ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Main log handler. Args: execution: The execution stack. log: log string from the RPC node. Returns: A three element array of the event, the next program that was invoked for CPI, and a boolean indicating if a program has completed execution (and thus should be popped off the execution stack). \"\"\" # Executing program is this program. if execution . stack and execution . program () == str ( self . program_id ): return self . handle_program_log ( log ) # Executing program is not this program. return ( None , * self . handle_system_log ( log )) handle_program_log ( self , log ) Handle logs from this program. Parameters: Name Type Description Default log str log string from the RPC node. required Source code in anchorpy/program/event.py def handle_program_log ( self , log : str ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Handle logs from *this* program. Args: log: log string from the RPC node. \"\"\" # This is a `msg!` log or a `sol_log_data!` log. if log . startswith ( PROGRAM_LOG ) or log . startswith ( PROGRAM_DATA ): log_str = ( log [ PROGRAM_LOG_START_INDEX :] if log . startswith ( PROGRAM_LOG ) else log [ PROGRAM_DATA_START_INDEX :] ) try : decoded = b64decode ( log_str ) except binascii . Error : return None , None , False event = self . coder . events . parse ( decoded ) return event , None , False return ( None , * self . handle_system_log ( log )) handle_system_log ( self , log ) Handle logs when the current program being executing is not this. Parameters: Name Type Description Default log str log string from the RPC node. required Source code in anchorpy/program/event.py def handle_system_log ( self , log : str ) -> tuple [ Optional [ str ], bool ]: \"\"\"Handle logs when the current program being executing is *not* this. Args: log: log string from the RPC node. \"\"\" log_start = log . split ( \":\" )[ 0 ] splitted = log_start . split ( \" \" ) invoke_msg = f \"Program { str ( self . program_id ) } invoke\" if len ( splitted ) == 3 and splitted [ 0 ] == \"Program\" and splitted [ 2 ] == \"success\" : return None , True if log_start . startswith ( invoke_msg ): return str ( self . program_id ), False if \"invoke\" in log_start : return \"cpi\" , False return None , False parse_logs ( self , logs , callback ) Parse a list of logs using a provided callback. Parameters: Name Type Description Default logs List[str] The logs to parse. required callback Callable[[anchorpy.program.common.Event], NoneType] The function to handle the parsed log. required Source code in anchorpy/program/event.py def parse_logs ( self , logs : List [ str ], callback : Callable [[ Event ], None ]) -> None : \"\"\"Parse a list of logs using a provided callback. Args: logs: The logs to parse. callback: The function to handle the parsed log. \"\"\" log_scanner = _LogScanner ( logs ) execution = _ExecutionContext ( cast ( str , log_scanner . to_next ())) log = log_scanner . to_next () while log is not None : event , new_program , did_pop = self . handle_log ( execution , log ) if event is not None : callback ( event ) if new_program is not None : execution . push ( new_program ) if did_pop : execution . pop () log = log_scanner . to_next () SimulateResponse ( tuple ) The result of a simulate function call. Source code in anchorpy/program/namespace/simulate.py class SimulateResponse ( NamedTuple ): \"\"\"The result of a simulate function call.\"\"\" events : list [ Event ] raw : list [ str ] error This module handles AnchorPy errors. AccountDoesNotExistError ( Exception ) Raise if account doesn't exist. Source code in anchorpy/error.py class AccountDoesNotExistError ( Exception ): \"\"\"Raise if account doesn't exist.\"\"\" AccountInvalidDiscriminator ( Exception ) Raise if account discriminator doesn't match the IDL. Source code in anchorpy/error.py class AccountInvalidDiscriminator ( Exception ): \"\"\"Raise if account discriminator doesn't match the IDL.\"\"\" ArgsError ( Exception ) Raise when the incorrect number of args is passed to the RPC function. Source code in anchorpy/error.py class ArgsError ( Exception ): \"\"\"Raise when the incorrect number of args is passed to the RPC function.\"\"\" IdlNotFoundError ( Exception ) Raise when requested IDL account does not exist. Source code in anchorpy/error.py class IdlNotFoundError ( Exception ): \"\"\"Raise when requested IDL account does not exist.\"\"\" ProgramError ( Exception ) An error from a user defined program. Source code in anchorpy/error.py class ProgramError ( Exception ): \"\"\"An error from a user defined program.\"\"\" def __init__ ( self , code : int , msg : Optional [ str ], logs : Optional [ list [ str ]] = None ) -> None : \"\"\"Init. Args: code: The error code. msg: The error message. logs: The transaction simulation logs. \"\"\" self . code = code self . msg = msg self . logs = logs super () . __init__ ( f \" { code } : { msg } \" ) @classmethod def parse ( cls , err_info : RPCError , idl_errors : dict [ int , str ], program_id : Pubkey , ) -> Optional [ ProgramError ]: \"\"\"Convert an RPC error into a ProgramError, if possible. Args: err_info: The RPC error. idl_errors: Errors from the IDL file. program_id: The ID of the program we expect the error to come from. Returns: A ProgramError or None. \"\"\" extracted = extract_code_and_logs ( err_info , program_id ) if extracted is None : return None code , logs = extracted msg = idl_errors . get ( code ) if msg is not None : return cls ( code , msg , logs ) # parse framework internal error msg = LangErrorMessage . get ( code ) if msg is not None : return cls ( code , msg , logs ) # Unable to parse the error. return None @classmethod def parse_tx_error ( cls , err_info : TransactionErrorType , idl_errors : dict [ int , str ], program_id : Pubkey , logs : List [ str ], ) -> Optional [ ProgramError ]: \"\"\"Convert an RPC error into a ProgramError, if possible. Args: err_info: The RPC error. idl_errors: Errors from the IDL file. program_id: The ID of the program we expect the error to come from. logs: The transaction logs. Returns: A ProgramError or None. \"\"\" code = extract_code_tx_error ( err_info , program_id , logs ) if code is None : return None msg = idl_errors . get ( code ) if msg is not None : return cls ( code , msg , logs ) # parse framework internal error msg = LangErrorMessage . get ( code ) if msg is not None : return cls ( code , msg , logs ) # Unable to parse the error. return None __init__ ( self , code , msg , logs = None ) special Init. Parameters: Name Type Description Default code int The error code. required msg Optional[str] The error message. required logs Optional[list[str]] The transaction simulation logs. None Source code in anchorpy/error.py def __init__ ( self , code : int , msg : Optional [ str ], logs : Optional [ list [ str ]] = None ) -> None : \"\"\"Init. Args: code: The error code. msg: The error message. logs: The transaction simulation logs. \"\"\" self . code = code self . msg = msg self . logs = logs super () . __init__ ( f \" { code } : { msg } \" ) parse ( err_info , idl_errors , program_id ) classmethod Convert an RPC error into a ProgramError, if possible. Parameters: Name Type Description Default err_info RPCError The RPC error. required idl_errors dict[int, str] Errors from the IDL file. required program_id Pubkey The ID of the program we expect the error to come from. required Returns: Type Description Optional[ProgramError] A ProgramError or None. Source code in anchorpy/error.py @classmethod def parse ( cls , err_info : RPCError , idl_errors : dict [ int , str ], program_id : Pubkey , ) -> Optional [ ProgramError ]: \"\"\"Convert an RPC error into a ProgramError, if possible. Args: err_info: The RPC error. idl_errors: Errors from the IDL file. program_id: The ID of the program we expect the error to come from. Returns: A ProgramError or None. \"\"\" extracted = extract_code_and_logs ( err_info , program_id ) if extracted is None : return None code , logs = extracted msg = idl_errors . get ( code ) if msg is not None : return cls ( code , msg , logs ) # parse framework internal error msg = LangErrorMessage . get ( code ) if msg is not None : return cls ( code , msg , logs ) # Unable to parse the error. return None parse_tx_error ( err_info , idl_errors , program_id , logs ) classmethod Convert an RPC error into a ProgramError, if possible. Parameters: Name Type Description Default err_info TransactionErrorType The RPC error. required idl_errors dict[int, str] Errors from the IDL file. required program_id Pubkey The ID of the program we expect the error to come from. required logs List[str] The transaction logs. required Returns: Type Description Optional[ProgramError] A ProgramError or None. Source code in anchorpy/error.py @classmethod def parse_tx_error ( cls , err_info : TransactionErrorType , idl_errors : dict [ int , str ], program_id : Pubkey , logs : List [ str ], ) -> Optional [ ProgramError ]: \"\"\"Convert an RPC error into a ProgramError, if possible. Args: err_info: The RPC error. idl_errors: Errors from the IDL file. program_id: The ID of the program we expect the error to come from. logs: The transaction logs. Returns: A ProgramError or None. \"\"\" code = extract_code_tx_error ( err_info , program_id , logs ) if code is None : return None msg = idl_errors . get ( code ) if msg is not None : return cls ( code , msg , logs ) # parse framework internal error msg = LangErrorMessage . get ( code ) if msg is not None : return cls ( code , msg , logs ) # Unable to parse the error. return None extract_code_and_logs ( err_info , program_id ) Extract the custom instruction error code from an RPC response. Parameters: Name Type Description Default err_info RPCError The RPC error. required program_id Pubkey The ID of the program we expect the error to come from. required Source code in anchorpy/error.py def extract_code_and_logs ( err_info : RPCError , program_id : Pubkey ) -> Optional [ Tuple [ int , List [ str ]]]: \"\"\"Extract the custom instruction error code from an RPC response. Args: err_info: The RPC error. program_id: The ID of the program we expect the error to come from. \"\"\" if isinstance ( err_info , SendTransactionPreflightFailureMessage ): err_data = err_info . data err_data_err = err_data . err logs = err_data . logs if logs is None : return None if err_data_err is None : return None maybe_code = _handle_ix_err ( err_data_err , logs , program_id ) return None if maybe_code is None else ( maybe_code , logs ) return None extract_code_tx_error ( err_info , program_id , logs ) Extract the custom instruction error code from a transaction error. Parameters: Name Type Description Default err_info TransactionErrorType The tx error. required program_id Pubkey The ID of the program we expect the error to come from. required logs List[str] The tx logs. required Source code in anchorpy/error.py def extract_code_tx_error ( err_info : TransactionErrorType , program_id : Pubkey , logs : List [ str ] ) -> Optional [ int ]: \"\"\"Extract the custom instruction error code from a transaction error. Args: err_info: The tx error. program_id: The ID of the program we expect the error to come from. logs: The tx logs. \"\"\" return _handle_ix_err ( err_info , logs , program_id ) utils special Various utility functions. rpc This module contains the invoke function. AccountInfo ( tuple ) Information describing an account. Attributes: Name Type Description executable bool True if this account's data contains a loaded program. owner Pubkey Identifier of the program that owns the account. lamports int Number of lamports assigned to the account. data bytes Optional data assigned to the account. rent_epoch Optional[int] Optional rent epoch info for for account. Source code in anchorpy/utils/rpc.py class AccountInfo ( NamedTuple ): \"\"\"Information describing an account. Attributes: executable: `True` if this account's data contains a loaded program. owner: Identifier of the program that owns the account. lamports: Number of lamports assigned to the account. data: Optional data assigned to the account. rent_epoch: Optional rent epoch info for for account. \"\"\" executable : bool owner : Pubkey lamports : int data : bytes rent_epoch : Optional [ int ] get_multiple_accounts ( connection , pubkeys , batch_size = 3 , commitment = None ) async Fetch multiple account infos through batched getMultipleAccount RPC requests. Parameters: Name Type Description Default connection AsyncClient The solana-py client object. required pubkeys list[solders.pubkey.Pubkey] Pubkeys to fetch. required batch_size int The number of getMultipleAccount objects to include in each HTTP request. 3 commitment Optional[solana.rpc.commitment.Commitment] Bank state to query. None Returns: Type Description list[Optional[anchorpy.utils.rpc._MultipleAccountsItem]] Account infos and pubkeys. Source code in anchorpy/utils/rpc.py async def get_multiple_accounts ( connection : AsyncClient , pubkeys : list [ Pubkey ], batch_size : int = 3 , commitment : Optional [ Commitment ] = None , ) -> list [ Optional [ _MultipleAccountsItem ]]: \"\"\"Fetch multiple account infos through batched `getMultipleAccount` RPC requests. Args: connection: The `solana-py` client object. pubkeys: Pubkeys to fetch. batch_size: The number of `getMultipleAccount` objects to include in each HTTP request. commitment: Bank state to query. Returns: Account infos and pubkeys. \"\"\" pubkeys_per_network_request = _GET_MULTIPLE_ACCOUNTS_LIMIT * batch_size chunks = partition_all ( pubkeys_per_network_request , pubkeys ) awaitables = [ _get_multiple_accounts_core ( connection , pubkeys_chunk , commitment ) for pubkeys_chunk in chunks ] results = await gather ( * awaitables , return_exceptions = False ) return list ( concat ( results )) token This module contains utilities for the SPL Token Program. create_mint_and_vault ( provider , amount , owner = None , decimals = None ) async Create a mint and a vault, then mint tokens to the vault. Parameters: Name Type Description Default provider Provider An anchorpy Provider instance. required amount int The amount of tokens to mint to the vault. required owner Optional[solders.pubkey.Pubkey] User account that will own the new account. None decimals Optional[int] The number of decimal places for the token to support. None Returns: Type Description tuple[solders.pubkey.Pubkey, solders.pubkey.Pubkey] The mint and vault pubkeys. Source code in anchorpy/utils/token.py async def create_mint_and_vault ( provider : Provider , amount : int , owner : Optional [ Pubkey ] = None , decimals : Optional [ int ] = None , ) -> tuple [ Pubkey , Pubkey ]: \"\"\"Create a mint and a vault, then mint tokens to the vault. Args: provider: An anchorpy Provider instance. amount: The amount of tokens to mint to the vault. owner: User account that will own the new account. decimals: The number of decimal places for the token to support. Returns: The mint and vault pubkeys. \"\"\" actual_owner = provider . wallet . public_key if owner is None else owner mint = Keypair () vault = Keypair () mint_space = 82 create_mint_mbre_resp = ( await provider . connection . get_minimum_balance_for_rent_exemption ( mint_space ) ) create_mint_mbre = create_mint_mbre_resp . value create_mint_account_params = CreateAccountParams ( from_pubkey = provider . wallet . public_key , to_pubkey = mint . pubkey (), space = mint_space , lamports = create_mint_mbre , owner = TOKEN_PROGRAM_ID , ) create_mint_account_instruction = create_account ( create_mint_account_params , ) init_mint_instruction = initialize_mint ( InitializeMintParams ( mint = mint . pubkey (), decimals = 0 if decimals is None else decimals , mint_authority = provider . wallet . public_key , program_id = TOKEN_PROGRAM_ID , ), ) vault_space = 165 create_vault_mbre_resp = ( await provider . connection . get_minimum_balance_for_rent_exemption ( vault_space ) ) create_vault_mbre = create_vault_mbre_resp . value create_vault_account_instruction = create_account ( CreateAccountParams ( from_pubkey = provider . wallet . public_key , to_pubkey = vault . pubkey (), space = vault_space , lamports = create_vault_mbre , owner = TOKEN_PROGRAM_ID , ), ) init_vault_instruction = initialize_account ( InitializeAccountParams ( program_id = TOKEN_PROGRAM_ID , account = vault . pubkey (), mint = mint . pubkey (), owner = actual_owner , ), ) mint_to_instruction = mint_to ( MintToParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), dest = vault . pubkey (), amount = amount , mint_authority = provider . wallet . public_key , ), ) blockhash = ( await provider . connection . get_latest_blockhash ( Confirmed ) ) . value . blockhash msg = Message . new_with_blockhash ( [ create_mint_account_instruction , init_mint_instruction , create_vault_account_instruction , init_vault_instruction , mint_to_instruction , ], provider . wallet . public_key , blockhash , ) tx = VersionedTransaction ( msg , [ provider . wallet . payer , mint , vault ]) await provider . send ( tx ) return mint . pubkey (), vault . pubkey () create_token_account ( prov , mint , owner ) async Create a token account. Parameters: Name Type Description Default prov Provider An anchorpy Provider instance. required mint Pubkey The pubkey of the token's mint. required owner Pubkey User account that will own the new account. required Returns: Type Description Pubkey The pubkey of the new account. Source code in anchorpy/utils/token.py async def create_token_account ( prov : Provider , mint : Pubkey , owner : Pubkey , ) -> Pubkey : \"\"\"Create a token account. Args: prov: An anchorpy Provider instance. mint: The pubkey of the token's mint. owner: User account that will own the new account. Returns: The pubkey of the new account. \"\"\" token = AsyncToken ( prov . connection , mint , TOKEN_PROGRAM_ID , prov . wallet . payer ) return await token . create_account ( owner ) create_token_account_instrs ( provider , new_account_pubkey , mint , owner ) async Generate instructions for creating a token account. Parameters: Name Type Description Default provider Provider An anchorpy Provider instance. required new_account_pubkey Pubkey The pubkey of the new account. required mint Pubkey The pubkey of the token's mint. required owner Pubkey User account that will own the new account. required Returns: Type Description tuple[solders.instruction.Instruction, solders.instruction.Instruction] Transaction instructions to create the new account. Source code in anchorpy/utils/token.py async def create_token_account_instrs ( provider : Provider , new_account_pubkey : Pubkey , mint : Pubkey , owner : Pubkey , ) -> tuple [ Instruction , Instruction ]: \"\"\"Generate instructions for creating a token account. Args: provider: An anchorpy Provider instance. new_account_pubkey: The pubkey of the new account. mint: The pubkey of the token's mint. owner: User account that will own the new account. Returns: Transaction instructions to create the new account. \"\"\" mbre_resp = await provider . connection . get_minimum_balance_for_rent_exemption ( 165 ) lamports = mbre_resp . value return ( create_account ( CreateAccountParams ( from_pubkey = provider . wallet . public_key , to_pubkey = new_account_pubkey , space = 165 , lamports = lamports , owner = TOKEN_PROGRAM_ID , ) ), initialize_account ( InitializeAccountParams ( account = new_account_pubkey , mint = mint , owner = owner , program_id = TOKEN_PROGRAM_ID , ) ), ) get_mint_info ( provider , addr ) async Retrieve mint information. Parameters: Name Type Description Default provider Provider The anchorpy Provider instance. required addr Pubkey The pubkey of the mint. required Returns: Type Description MintInfo The parsed MintInfo . Source code in anchorpy/utils/token.py async def get_mint_info ( provider : Provider , addr : Pubkey , ) -> MintInfo : \"\"\"Retrieve mint information. Args: provider: The anchorpy Provider instance. addr: The pubkey of the mint. Returns: The parsed `MintInfo`. \"\"\" depositor_acc_info_raw = await provider . connection . get_account_info ( addr ) return parse_mint_account ( depositor_acc_info_raw ) get_token_account ( provider , addr ) async Retrieve token account information. Parameters: Name Type Description Default provider Provider The anchorpy Provider instance. required addr Pubkey The pubkey of the token account. required Returns: Type Description AccountInfo The parsed AccountInfo of the token account. Source code in anchorpy/utils/token.py async def get_token_account ( provider : Provider , addr : Pubkey ) -> AccountInfo : \"\"\"Retrieve token account information. Args: provider: The anchorpy Provider instance. addr: The pubkey of the token account. Returns: The parsed `AccountInfo` of the token account. \"\"\" depositor_acc_info_raw = await provider . connection . get_account_info ( addr ) return parse_token_account ( depositor_acc_info_raw ) parse_mint_account ( info ) Parse raw RPC response into MintInfo . Parameters: Name Type Description Default info GetAccountInfoResp The RPC response from calling .get_account_info for the mint pubkey. required Exceptions: Type Description AttributeError If the account is not owned by the Token Program. ValueError If the fetched data is the wrong size. Returns: Type Description MintInfo The parsed MintInfo . Source code in anchorpy/utils/token.py def parse_mint_account ( info : GetAccountInfoResp ) -> MintInfo : \"\"\"Parse raw RPC response into `MintInfo`. Args: info: The RPC response from calling `.get_account_info` for the mint pubkey. Raises: AttributeError: If the account is not owned by the Token Program. ValueError: If the fetched data is the wrong size. Returns: The parsed `MintInfo`. \"\"\" val = info . value if val is None : raise ValueError ( \"Account does not exist.\" ) owner = val . owner if owner != TOKEN_PROGRAM_ID : raise AttributeError ( f \"Invalid mint owner: { owner } \" ) bytes_data = val . data if len ( bytes_data ) != MINT_LAYOUT . sizeof (): raise ValueError ( \"Invalid mint size\" ) decoded_data = MINT_LAYOUT . parse ( bytes_data ) decimals = decoded_data . decimals mint_authority = ( None if decoded_data . mint_authority_option == 0 else Pubkey ( decoded_data . mint_authority ) ) supply = decoded_data . supply is_initialized = decoded_data . is_initialized != 0 if decoded_data . freeze_authority_option == 0 : freeze_authority = None else : freeze_authority = Pubkey ( decoded_data . freeze_authority ) return MintInfo ( mint_authority , supply , decimals , is_initialized , freeze_authority ) parse_token_account ( info ) Parse AccountInfo from RPC response. Parameters: Name Type Description Default info GetAccountInfoResp the get_account_info RPC response. required Exceptions: Type Description ValueError If the fetched data is the wrong size. AttributeError If the account is not owned by the token program. Returns: Type Description AccountInfo The parsed AccountInfo . Source code in anchorpy/utils/token.py def parse_token_account ( info : GetAccountInfoResp ) -> AccountInfo : \"\"\"Parse `AccountInfo` from RPC response. Args: info: the `get_account_info` RPC response. Raises: ValueError: If the fetched data is the wrong size. AttributeError: If the account is not owned by the token program. Returns: The parsed `AccountInfo`. \"\"\" val = info . value if not val : raise ValueError ( \"Invalid account owner\" ) if val . owner != TOKEN_PROGRAM_ID : raise AttributeError ( \"Invalid account owner\" ) bytes_data = val . data if len ( bytes_data ) != ACCOUNT_LAYOUT . sizeof (): raise ValueError ( \"Invalid account size\" ) decoded_data = ACCOUNT_LAYOUT . parse ( bytes_data ) mint = Pubkey ( decoded_data . mint ) owner = Pubkey ( decoded_data . owner ) amount = decoded_data . amount if decoded_data . delegate_option == 0 : delegate = None delegated_amount = 0 else : delegate = Pubkey ( decoded_data . delegate ) delegated_amount = decoded_data . delegated_amount is_initialized = decoded_data . state != 0 is_frozen = decoded_data . state == 2 if decoded_data . is_native_option == 1 : rent_exempt_reserve = decoded_data . is_native is_native = True else : rent_exempt_reserve = None is_native = False if decoded_data . close_authority_option == 0 : close_authority = None else : close_authority = Pubkey ( decoded_data . owner ) return AccountInfo ( mint , owner , amount , delegate , delegated_amount , is_initialized , is_frozen , is_native , rent_exempt_reserve , close_authority , )","title":"API Reference"},{"location":"dynamic_client/api_reference/#api-reference","text":"","title":"API Reference"},{"location":"dynamic_client/api_reference/#anchorpy.program.core.Program","text":"Program provides the IDL deserialized client representation of an Anchor program. This API is the one stop shop for all things related to communicating with on-chain programs. Among other things, one can send transactions, fetch deserialized accounts, decode instruction data, subscribe to account changes, and listen to events. In addition to field accessors and methods, the object provides a set of dynamically generated properties, also known as namespaces, that map one-to-one to program methods and accounts. Source code in anchorpy/program/core.py class Program ( object ): \"\"\"Program provides the IDL deserialized client representation of an Anchor program. This API is the one stop shop for all things related to communicating with on-chain programs. Among other things, one can send transactions, fetch deserialized accounts, decode instruction data, subscribe to account changes, and listen to events. In addition to field accessors and methods, the object provides a set of dynamically generated properties, also known as namespaces, that map one-to-one to program methods and accounts. \"\"\" def __init__ ( self , idl : Idl , program_id : Pubkey , provider : Optional [ Provider ] = None ): \"\"\"Initialize the Program object. Args: idl: The parsed IDL object. program_id: The program ID. provider: The Provider object for the Program. Defaults to Provider.local(). \"\"\" self . idl = idl self . program_id = program_id self . provider = provider if provider is not None else Provider . local () self . coder = Coder ( idl ) ( rpc , instruction , transaction , account , simulate , types , methods , ) = _build_namespace ( idl , self . coder , program_id , self . provider , ) self . rpc = rpc self . instruction = instruction self . transaction = transaction self . account = account self . simulate = simulate self . type = types self . methods = methods async def __aenter__ ( self ) -> Program : \"\"\"Use as a context manager.\"\"\" await self . provider . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exit the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . provider . close () @staticmethod async def fetch_raw_idl ( address : AddressType , provider : Provider , ) -> str : \"\"\"Fetch an idl from the blockchain as a raw JSON dictionary. Args: address: The program ID. provider: The network and wallet context. Raises: IdlNotFoundError: If the requested IDL account does not exist. Returns: str: The raw IDL. \"\"\" program_id = translate_address ( address ) actual_provider = provider if provider is not None else Provider . local () idl_addr = _idl_address ( program_id ) account_info = await actual_provider . connection . get_account_info ( idl_addr ) account_info_val = account_info . value if account_info_val is None : raise IdlNotFoundError ( f \"IDL not found for program: { address } \" ) idl_account = _decode_idl_account ( account_info_val . data [ ACCOUNT_DISCRIMINATOR_SIZE :] ) return _pako_inflate ( bytes ( idl_account [ \"data\" ])) . decode () @classmethod async def fetch_idl ( cls , address : AddressType , provider : Provider , ) -> Idl : \"\"\"Fetch and parse an idl from the blockchain. Args: address: The program ID. provider: The network and wallet context. Returns: Idl: The fetched IDL. \"\"\" raw = await cls . fetch_raw_idl ( address , provider ) return Idl . from_json ( raw ) @classmethod async def at ( cls , address : AddressType , provider : Optional [ Provider ] = None , ) -> Program : \"\"\"Generate a Program client by fetching the IDL from the network. In order to use this method, an IDL must have been previously initialized via the anchor CLI's `anchor idl init` command. Args: address: The program ID. provider: The network and wallet context. Returns: The Program instantiated using the fetched IDL. \"\"\" provider_to_use = Provider . local () if provider is None else provider program_id = translate_address ( address ) idl = await cls . fetch_idl ( program_id , provider_to_use ) return cls ( idl , program_id , provider )","title":"Program"},{"location":"dynamic_client/api_reference/#anchorpy.program.core.Program.__init__","text":"Initialize the Program object. Parameters: Name Type Description Default idl Idl The parsed IDL object. required program_id Pubkey The program ID. required provider Optional[Provider] The Provider object for the Program. Defaults to Provider.local(). None Source code in anchorpy/program/core.py def __init__ ( self , idl : Idl , program_id : Pubkey , provider : Optional [ Provider ] = None ): \"\"\"Initialize the Program object. Args: idl: The parsed IDL object. program_id: The program ID. provider: The Provider object for the Program. Defaults to Provider.local(). \"\"\" self . idl = idl self . program_id = program_id self . provider = provider if provider is not None else Provider . local () self . coder = Coder ( idl ) ( rpc , instruction , transaction , account , simulate , types , methods , ) = _build_namespace ( idl , self . coder , program_id , self . provider , ) self . rpc = rpc self . instruction = instruction self . transaction = transaction self . account = account self . simulate = simulate self . type = types self . methods = methods","title":"__init__()"},{"location":"dynamic_client/api_reference/#anchorpy.program.core.Program.at","text":"Generate a Program client by fetching the IDL from the network. In order to use this method, an IDL must have been previously initialized via the anchor CLI's anchor idl init command. Parameters: Name Type Description Default address AddressType The program ID. required provider Optional[Provider] The network and wallet context. None Returns: Type Description Program The Program instantiated using the fetched IDL. Source code in anchorpy/program/core.py @classmethod async def at ( cls , address : AddressType , provider : Optional [ Provider ] = None , ) -> Program : \"\"\"Generate a Program client by fetching the IDL from the network. In order to use this method, an IDL must have been previously initialized via the anchor CLI's `anchor idl init` command. Args: address: The program ID. provider: The network and wallet context. Returns: The Program instantiated using the fetched IDL. \"\"\" provider_to_use = Provider . local () if provider is None else provider program_id = translate_address ( address ) idl = await cls . fetch_idl ( program_id , provider_to_use ) return cls ( idl , program_id , provider )","title":"at()"},{"location":"dynamic_client/api_reference/#anchorpy.program.core.Program.close","text":"Use this when you are done with the client. Source code in anchorpy/program/core.py async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . provider . close ()","title":"close()"},{"location":"dynamic_client/api_reference/#anchorpy.program.core.Program.fetch_idl","text":"Fetch and parse an idl from the blockchain. Parameters: Name Type Description Default address AddressType The program ID. required provider Provider The network and wallet context. required Returns: Type Description Idl The fetched IDL. Source code in anchorpy/program/core.py @classmethod async def fetch_idl ( cls , address : AddressType , provider : Provider , ) -> Idl : \"\"\"Fetch and parse an idl from the blockchain. Args: address: The program ID. provider: The network and wallet context. Returns: Idl: The fetched IDL. \"\"\" raw = await cls . fetch_raw_idl ( address , provider ) return Idl . from_json ( raw )","title":"fetch_idl()"},{"location":"dynamic_client/api_reference/#anchorpy.program.core.Program.fetch_raw_idl","text":"Fetch an idl from the blockchain as a raw JSON dictionary. Parameters: Name Type Description Default address AddressType The program ID. required provider Provider The network and wallet context. required Exceptions: Type Description IdlNotFoundError If the requested IDL account does not exist. Returns: Type Description str The raw IDL. Source code in anchorpy/program/core.py @staticmethod async def fetch_raw_idl ( address : AddressType , provider : Provider , ) -> str : \"\"\"Fetch an idl from the blockchain as a raw JSON dictionary. Args: address: The program ID. provider: The network and wallet context. Raises: IdlNotFoundError: If the requested IDL account does not exist. Returns: str: The raw IDL. \"\"\" program_id = translate_address ( address ) actual_provider = provider if provider is not None else Provider . local () idl_addr = _idl_address ( program_id ) account_info = await actual_provider . connection . get_account_info ( idl_addr ) account_info_val = account_info . value if account_info_val is None : raise IdlNotFoundError ( f \"IDL not found for program: { address } \" ) idl_account = _decode_idl_account ( account_info_val . data [ ACCOUNT_DISCRIMINATOR_SIZE :] ) return _pako_inflate ( bytes ( idl_account [ \"data\" ])) . decode ()","title":"fetch_raw_idl()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Provider","text":"The network and wallet context used to send transactions paid for and signed by the provider. Source code in anchorpy/provider.py class Provider : \"\"\"The network and wallet context used to send transactions paid for and signed by the provider.\"\"\" # noqa: E501 def __init__ ( self , connection : AsyncClient , wallet : Wallet , opts : types . TxOpts = DEFAULT_OPTIONS , ) -> None : \"\"\"Initialize the Provider. Args: connection: The cluster connection where the program is deployed. wallet: The wallet used to pay for and sign all transactions. opts: Transaction confirmation options to use by default. \"\"\" self . connection = connection self . wallet = wallet self . opts = opts @classmethod def local ( cls , url : Optional [ str ] = None , opts : types . TxOpts = DEFAULT_OPTIONS ) -> Provider : \"\"\"Create a `Provider` with a wallet read from the local filesystem. Args: url: The network cluster url. opts: The default transaction confirmation options. \"\"\" connection = AsyncClient ( url , opts . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , opts ) @classmethod def readonly ( cls , url : Optional [ str ] = None , opts : types . TxOpts = DEFAULT_OPTIONS ) -> Provider : \"\"\"Create a `Provider` that can only fetch data, not send transactions. Args: url: The network cluster url. opts: The default transaction confirmation options. \"\"\" connection = AsyncClient ( url , opts . preflight_commitment ) wallet = Wallet . dummy () return cls ( connection , wallet , opts ) @classmethod def env ( cls ) -> Provider : \"\"\"Create a `Provider` using the `ANCHOR_PROVIDER_URL` environment variable.\"\"\" url = environ [ \"ANCHOR_PROVIDER_URL\" ] options = DEFAULT_OPTIONS connection = AsyncClient ( url , options . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , options ) async def simulate ( self , tx : Union [ Transaction , VersionedTransaction ], opts : Optional [ types . TxOpts ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate the given transaction, returning emitted logs from execution. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction simulation result. \"\"\" if opts is None : opts = self . opts return await self . connection . simulate_transaction ( tx , sig_verify = True , commitment = opts . preflight_commitment ) async def send ( self , tx : Union [ Transaction , VersionedTransaction ], opts : Optional [ types . TxOpts ] = None , ) -> Signature : \"\"\"Send the given transaction, paid for and signed by the provider's wallet. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction signature from the RPC server. \"\"\" if opts is None : opts = self . opts raw = bytes ( tx ) resp = await self . connection . send_raw_transaction ( raw , opts = opts ) return resp . value async def send_all ( self , txs : Sequence [ Union [ Transaction , VersionedTransaction ]], opts : Optional [ types . TxOpts ] = None , ) -> list [ Signature ]: \"\"\"Similar to `send`, but for an array of transactions and signers. Args: txs: a list of transaction objects. opts: Transaction confirmation options. Returns: The transaction signatures from the RPC server. \"\"\" if opts is None : opts = self . opts sigs = [] for tx in txs : raw = bytes ( tx ) resp = await self . connection . send_raw_transaction ( raw , opts = opts ) sigs . append ( resp . value ) return sigs async def __aenter__ ( self ) -> Provider : \"\"\"Use as a context manager.\"\"\" await self . connection . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exit the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Use this when you are done with the connection.\"\"\" await self . connection . close ()","title":"Provider"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Provider.__init__","text":"Initialize the Provider. Parameters: Name Type Description Default connection AsyncClient The cluster connection where the program is deployed. required wallet Wallet The wallet used to pay for and sign all transactions. required opts types.TxOpts Transaction confirmation options to use by default. TxOpts(skip_confirmation=False, skip_preflight=False, preflight_commitment='processed', max_retries=None, last_valid_block_height=None) Source code in anchorpy/provider.py def __init__ ( self , connection : AsyncClient , wallet : Wallet , opts : types . TxOpts = DEFAULT_OPTIONS , ) -> None : \"\"\"Initialize the Provider. Args: connection: The cluster connection where the program is deployed. wallet: The wallet used to pay for and sign all transactions. opts: Transaction confirmation options to use by default. \"\"\" self . connection = connection self . wallet = wallet self . opts = opts","title":"__init__()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Provider.close","text":"Use this when you are done with the connection. Source code in anchorpy/provider.py async def close ( self ) -> None : \"\"\"Use this when you are done with the connection.\"\"\" await self . connection . close ()","title":"close()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Provider.env","text":"Create a Provider using the ANCHOR_PROVIDER_URL environment variable. Source code in anchorpy/provider.py @classmethod def env ( cls ) -> Provider : \"\"\"Create a `Provider` using the `ANCHOR_PROVIDER_URL` environment variable.\"\"\" url = environ [ \"ANCHOR_PROVIDER_URL\" ] options = DEFAULT_OPTIONS connection = AsyncClient ( url , options . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , options )","title":"env()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Provider.local","text":"Create a Provider with a wallet read from the local filesystem. Parameters: Name Type Description Default url Optional[str] The network cluster url. None opts types.TxOpts The default transaction confirmation options. TxOpts(skip_confirmation=False, skip_preflight=False, preflight_commitment='processed', max_retries=None, last_valid_block_height=None) Source code in anchorpy/provider.py @classmethod def local ( cls , url : Optional [ str ] = None , opts : types . TxOpts = DEFAULT_OPTIONS ) -> Provider : \"\"\"Create a `Provider` with a wallet read from the local filesystem. Args: url: The network cluster url. opts: The default transaction confirmation options. \"\"\" connection = AsyncClient ( url , opts . preflight_commitment ) wallet = Wallet . local () return cls ( connection , wallet , opts )","title":"local()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Provider.readonly","text":"Create a Provider that can only fetch data, not send transactions. Parameters: Name Type Description Default url Optional[str] The network cluster url. None opts types.TxOpts The default transaction confirmation options. TxOpts(skip_confirmation=False, skip_preflight=False, preflight_commitment='processed', max_retries=None, last_valid_block_height=None) Source code in anchorpy/provider.py @classmethod def readonly ( cls , url : Optional [ str ] = None , opts : types . TxOpts = DEFAULT_OPTIONS ) -> Provider : \"\"\"Create a `Provider` that can only fetch data, not send transactions. Args: url: The network cluster url. opts: The default transaction confirmation options. \"\"\" connection = AsyncClient ( url , opts . preflight_commitment ) wallet = Wallet . dummy () return cls ( connection , wallet , opts )","title":"readonly()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Provider.send","text":"Send the given transaction, paid for and signed by the provider's wallet. Parameters: Name Type Description Default tx Union[Transaction, VersionedTransaction] The transaction to send. required signers The set of signers in addition to the provider wallet that will sign the transaction. required opts Optional[types.TxOpts] Transaction confirmation options. None Returns: Type Description Signature The transaction signature from the RPC server. Source code in anchorpy/provider.py async def send ( self , tx : Union [ Transaction , VersionedTransaction ], opts : Optional [ types . TxOpts ] = None , ) -> Signature : \"\"\"Send the given transaction, paid for and signed by the provider's wallet. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction signature from the RPC server. \"\"\" if opts is None : opts = self . opts raw = bytes ( tx ) resp = await self . connection . send_raw_transaction ( raw , opts = opts ) return resp . value","title":"send()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Provider.send_all","text":"Similar to send , but for an array of transactions and signers. Parameters: Name Type Description Default txs Sequence[Union[Transaction, VersionedTransaction]] a list of transaction objects. required opts Optional[types.TxOpts] Transaction confirmation options. None Returns: Type Description list[Signature] The transaction signatures from the RPC server. Source code in anchorpy/provider.py async def send_all ( self , txs : Sequence [ Union [ Transaction , VersionedTransaction ]], opts : Optional [ types . TxOpts ] = None , ) -> list [ Signature ]: \"\"\"Similar to `send`, but for an array of transactions and signers. Args: txs: a list of transaction objects. opts: Transaction confirmation options. Returns: The transaction signatures from the RPC server. \"\"\" if opts is None : opts = self . opts sigs = [] for tx in txs : raw = bytes ( tx ) resp = await self . connection . send_raw_transaction ( raw , opts = opts ) sigs . append ( resp . value ) return sigs","title":"send_all()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Provider.simulate","text":"Simulate the given transaction, returning emitted logs from execution. Parameters: Name Type Description Default tx Union[Transaction, VersionedTransaction] The transaction to send. required signers The set of signers in addition to the provider wallet that will sign the transaction. required opts Optional[types.TxOpts] Transaction confirmation options. None Returns: Type Description SimulateTransactionResp The transaction simulation result. Source code in anchorpy/provider.py async def simulate ( self , tx : Union [ Transaction , VersionedTransaction ], opts : Optional [ types . TxOpts ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate the given transaction, returning emitted logs from execution. Args: tx: The transaction to send. signers: The set of signers in addition to the provider wallet that will sign the transaction. opts: Transaction confirmation options. Returns: The transaction simulation result. \"\"\" if opts is None : opts = self . opts return await self . connection . simulate_transaction ( tx , sig_verify = True , commitment = opts . preflight_commitment )","title":"simulate()"},{"location":"dynamic_client/api_reference/#anchorpy.program.context.Context","text":"Context provides all non-argument inputs for generating Anchor transactions. Attributes: Name Type Description accounts Dict[str, Any] The accounts used in the instruction context. remaining_accounts List[solders.instruction.AccountMeta] All accounts to pass into an instruction after the main signers List[solders.keypair.Keypair] Accounts that must sign a given transaction. pre_instructions List[solders.instruction.Instruction] Instructions to run before a given method. Often this is used, for example to create accounts prior to executing a method. post_instructions List[solders.instruction.Instruction] Instructions to run after a given method. Often this is used, for example to close accounts prior to executing a method. options Optional[solana.rpc.types.TxOpts] Commitment parameters to use for a transaction. Source code in anchorpy/program/context.py @dataclass class Context : \"\"\"Context provides all non-argument inputs for generating Anchor transactions. Attributes: accounts: The accounts used in the instruction context. remaining_accounts: All accounts to pass into an instruction *after* the main `accounts`. This can be used for optional or otherwise unknown accounts. signers: Accounts that must sign a given transaction. pre_instructions: Instructions to run *before* a given method. Often this is used, for example to create accounts prior to executing a method. post_instructions: Instructions to run *after* a given method. Often this is used, for example to close accounts prior to executing a method. options: Commitment parameters to use for a transaction. \"\"\" # For some reason mkdocstrings doesn't understand the full type hint # here if we use list[Instruction] instead of typing.List. # Weirdly there are other places where it understands list[whatever]. accounts : Accounts = field ( default_factory = dict ) remaining_accounts : List [ AccountMeta ] = field ( default_factory = list ) signers : List [ Keypair ] = field ( default_factory = list ) pre_instructions : List [ Instruction ] = field ( default_factory = list ) post_instructions : List [ Instruction ] = field ( default_factory = list ) options : Optional [ TxOpts ] = None","title":"Context"},{"location":"dynamic_client/api_reference/#anchorpy.workspace.create_workspace","text":"Get a workspace from the provided path to the project root. Parameters: Name Type Description Default path Union[pathlib._local.Path, str] The path to the project root. Defaults to the current working directory if omitted. None url Optional[str] The URL of the JSON RPC. Defaults to http://localhost:8899. None Returns: Type Description Dict[str, anchorpy.program.core.Program] Mapping of program name to Program object. Source code in anchorpy/workspace.py def create_workspace ( path : Optional [ Union [ Path , str ]] = None , url : Optional [ str ] = None ) -> WorkspaceType : \"\"\"Get a workspace from the provided path to the project root. Args: path: The path to the project root. Defaults to the current working directory if omitted. url: The URL of the JSON RPC. Defaults to http://localhost:8899. Returns: Mapping of program name to Program object. \"\"\" result = {} project_root = Path . cwd () if path is None else Path ( path ) idl_folder = project_root / \"target/idl\" localnet_programs : dict [ str , str ] = toml . load ( project_root / \"Anchor.toml\" )[ \"programs\" ][ \"localnet\" ] for file in idl_folder . iterdir (): raw = file . read_text () idl = Idl . from_json ( raw ) name = idl . name program_id = Pubkey . from_string ( localnet_programs [ name ]) program = Program ( idl , program_id , Provider . local ( url )) result [ idl . name ] = program return result","title":"create_workspace()"},{"location":"dynamic_client/api_reference/#anchorpy.workspace.close_workspace","text":"Close the HTTP clients of all the programs in the workspace. Parameters: Name Type Description Default workspace Dict[str, anchorpy.program.core.Program] The workspace to close. required Source code in anchorpy/workspace.py async def close_workspace ( workspace : WorkspaceType ) -> None : \"\"\"Close the HTTP clients of all the programs in the workspace. Args: workspace: The workspace to close. \"\"\" for program in workspace . values (): # could do this in a faster way but there's probably no point. await program . close ()","title":"close_workspace()"},{"location":"dynamic_client/api_reference/#anchorpy.pytest_plugin.workspace_fixture","text":"Create a fixture that sets up and tears down a localnet instance and returns a workspace dict. Equivalent to combining localnet_fixture , create_workspace and close_workspace . Parameters: Name Type Description Default path Union[pathlib._local.Path, str] Path to root of the Anchor project. required scope Literal['session', 'package', 'module', 'class', 'function'] Pytest fixture scope. 'module' timeout_seconds int Time to wait for Anchor localnet to start. 60 build_cmd Optional[str] Command to run before anchor localnet . Defaults to anchor build . None Returns: Type Description Callable A workspace fixture for use with pytest. Source code in anchorpy/pytest_plugin.py def workspace_fixture ( path : Union [ Path , str ], scope : _Scope = \"module\" , timeout_seconds : int = 60 , build_cmd : Optional [ str ] = None , ) -> Callable : \"\"\"Create a fixture that sets up and tears down a localnet instance and returns a workspace dict. Equivalent to combining `localnet_fixture`, `create_workspace` and `close_workspace`. Args: path: Path to root of the Anchor project. scope: Pytest fixture scope. timeout_seconds: Time to wait for Anchor localnet to start. build_cmd: Command to run before `anchor localnet`. Defaults to `anchor build`. Returns: A workspace fixture for use with pytest. \"\"\" # noqa: E501,D202 @async_fixture ( scope = scope ) async def _workspace_fixture ( _fixed_xprocess , ) -> AsyncGenerator [ dict [ str , Program ], None ]: class Starter ( ProcessStarter ): # startup pattern pattern = \"JSON RPC URL\" terminate_on_interrupt = True # command to start process args = [ \"anchor\" , \"localnet\" , \"--skip-build\" ] timeout = timeout_seconds popen_kwargs = { \"cwd\" : path , \"start_new_session\" : True , } max_read_lines = 1_000 # command to start process actual_build_cmd = \"anchor build\" if build_cmd is None else build_cmd subprocess . run ( actual_build_cmd , cwd = path , check = True , shell = True ) # ensure process is running _ = _fixed_xprocess . ensure ( \"localnet\" , Starter ) ws = create_workspace ( path ) yield ws await close_workspace ( ws ) # clean up whole process tree afterwards _fixed_xprocess . getinfo ( \"localnet\" ) . terminate () return _workspace_fixture","title":"workspace_fixture()"},{"location":"dynamic_client/api_reference/#anchorpy.pytest_plugin.localnet_fixture","text":"Create a fixture that sets up and tears down a localnet instance with workspace programs deployed. Parameters: Name Type Description Default path Path Path to root of the Anchor project. required scope Literal['session', 'package', 'module', 'class', 'function'] Pytest fixture scope. 'module' timeout_seconds int Time to wait for Anchor localnet to start. 60 build_cmd Optional[str] Command to run before anchor localnet . Defaults to anchor build . None Returns: Type Description Callable A localnet fixture for use with pytest. Source code in anchorpy/pytest_plugin.py def localnet_fixture ( path : Path , scope : _Scope = \"module\" , timeout_seconds : int = 60 , build_cmd : Optional [ str ] = None , ) -> Callable : \"\"\"Create a fixture that sets up and tears down a localnet instance with workspace programs deployed. Args: path: Path to root of the Anchor project. scope: Pytest fixture scope. timeout_seconds: Time to wait for Anchor localnet to start. build_cmd: Command to run before `anchor localnet`. Defaults to `anchor build`. Returns: A localnet fixture for use with pytest. \"\"\" # noqa: E501,D202 @fixture ( scope = scope ) def _localnet_fixture ( _fixed_xprocess ): class Starter ( ProcessStarter ): # startup pattern pattern = \"JSON RPC URL\" terminate_on_interrupt = True # command to start process args = [ \"anchor\" , \"localnet\" , \"--skip-build\" ] timeout = timeout_seconds popen_kwargs = { \"cwd\" : path , \"start_new_session\" : True , } max_read_lines = 1_000 # command to start process actual_build_cmd = \"anchor build\" if build_cmd is None else build_cmd subprocess . run ( actual_build_cmd , cwd = path , check = True , shell = True ) # ensure process is running and return its logfile logfile = _fixed_xprocess . ensure ( \"localnet\" , Starter ) yield logfile # clean up whole process tree afterwards _fixed_xprocess . getinfo ( \"localnet\" ) . terminate () return _localnet_fixture","title":"localnet_fixture()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Wallet","text":"Python wallet object. Source code in anchorpy/provider.py class Wallet : \"\"\"Python wallet object.\"\"\" def __init__ ( self , payer : Keypair ): \"\"\"Initialize the wallet. Args: payer: the Keypair used to sign transactions. \"\"\" self . payer = payer @property def public_key ( self ) -> Pubkey : \"\"\"Get the public key of the wallet.\"\"\" return self . payer . pubkey () def sign_transaction ( self , tx : Transaction ) -> Transaction : \"\"\"Sign a transaction using the wallet's keypair. Args: tx: The transaction to sign. Returns: The signed transaction. \"\"\" tx . sign ([ self . payer ], tx . message . recent_blockhash ) return tx def sign_all_transactions ( self , txs : list [ Transaction ]) -> list [ Transaction ]: \"\"\"Sign a list of transactions using the wallet's keypair. Args: txs: The transactions to sign. Returns: The signed transactions. \"\"\" for tx in txs : tx . partial_sign ([ self . payer ], tx . message . recent_blockhash ) return txs @classmethod def local ( cls ) -> Wallet : \"\"\"Create a wallet instance from the filesystem. Uses the path at the ANCHOR_WALLET env var if set, otherwise uses ~/.config/solana/id.json. \"\"\" path = Path ( getenv ( \"ANCHOR_WALLET\" , Path . home () / \".config/solana/id.json\" )) with path . open () as f : keypair : List [ int ] = json . load ( f ) return cls ( Keypair . from_bytes ( keypair )) @classmethod def dummy ( cls ) -> Wallet : \"\"\"Create a dummy wallet instance that won't be used to sign transactions.\"\"\" keypair = Keypair () return cls ( keypair )","title":"Wallet"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Wallet.public_key","text":"Get the public key of the wallet.","title":"public_key"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Wallet.__init__","text":"Initialize the wallet. Parameters: Name Type Description Default payer Keypair the Keypair used to sign transactions. required Source code in anchorpy/provider.py def __init__ ( self , payer : Keypair ): \"\"\"Initialize the wallet. Args: payer: the Keypair used to sign transactions. \"\"\" self . payer = payer","title":"__init__()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Wallet.dummy","text":"Create a dummy wallet instance that won't be used to sign transactions. Source code in anchorpy/provider.py @classmethod def dummy ( cls ) -> Wallet : \"\"\"Create a dummy wallet instance that won't be used to sign transactions.\"\"\" keypair = Keypair () return cls ( keypair )","title":"dummy()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Wallet.local","text":"Create a wallet instance from the filesystem. Uses the path at the ANCHOR_WALLET env var if set, otherwise uses ~/.config/solana/id.json. Source code in anchorpy/provider.py @classmethod def local ( cls ) -> Wallet : \"\"\"Create a wallet instance from the filesystem. Uses the path at the ANCHOR_WALLET env var if set, otherwise uses ~/.config/solana/id.json. \"\"\" path = Path ( getenv ( \"ANCHOR_WALLET\" , Path . home () / \".config/solana/id.json\" )) with path . open () as f : keypair : List [ int ] = json . load ( f ) return cls ( Keypair . from_bytes ( keypair ))","title":"local()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Wallet.sign_all_transactions","text":"Sign a list of transactions using the wallet's keypair. Parameters: Name Type Description Default txs list[Transaction] The transactions to sign. required Returns: Type Description list[Transaction] The signed transactions. Source code in anchorpy/provider.py def sign_all_transactions ( self , txs : list [ Transaction ]) -> list [ Transaction ]: \"\"\"Sign a list of transactions using the wallet's keypair. Args: txs: The transactions to sign. Returns: The signed transactions. \"\"\" for tx in txs : tx . partial_sign ([ self . payer ], tx . message . recent_blockhash ) return txs","title":"sign_all_transactions()"},{"location":"dynamic_client/api_reference/#anchorpy.provider.Wallet.sign_transaction","text":"Sign a transaction using the wallet's keypair. Parameters: Name Type Description Default tx Transaction The transaction to sign. required Returns: Type Description Transaction The signed transaction. Source code in anchorpy/provider.py def sign_transaction ( self , tx : Transaction ) -> Transaction : \"\"\"Sign a transaction using the wallet's keypair. Args: tx: The transaction to sign. Returns: The signed transaction. \"\"\" tx . sign ([ self . payer ], tx . message . recent_blockhash ) return tx","title":"sign_transaction()"},{"location":"dynamic_client/api_reference/#anchorpy.coder.coder.Coder","text":"Coder provides a facade for encoding and decoding all IDL related objects. Source code in anchorpy/coder/coder.py class Coder : \"\"\"Coder provides a facade for encoding and decoding all IDL related objects.\"\"\" def __init__ ( self , idl : Idl ): \"\"\"Initialize the coder. Args: idl: a parsed Idl instance. \"\"\" self . instruction : InstructionCoder = InstructionCoder ( idl ) self . accounts : AccountsCoder = AccountsCoder ( idl ) self . events : EventCoder = EventCoder ( idl ) self . types : TypesCoder = TypesCoder ( idl )","title":"Coder"},{"location":"dynamic_client/api_reference/#anchorpy.coder.coder.Coder.__init__","text":"Initialize the coder. Parameters: Name Type Description Default idl Idl a parsed Idl instance. required Source code in anchorpy/coder/coder.py def __init__ ( self , idl : Idl ): \"\"\"Initialize the coder. Args: idl: a parsed Idl instance. \"\"\" self . instruction : InstructionCoder = InstructionCoder ( idl ) self . accounts : AccountsCoder = AccountsCoder ( idl ) self . events : EventCoder = EventCoder ( idl ) self . types : TypesCoder = TypesCoder ( idl )","title":"__init__()"},{"location":"dynamic_client/api_reference/#anchorpy.coder.instruction.InstructionCoder","text":"Encodes and decodes program instructions. Source code in anchorpy/coder/instruction.py class InstructionCoder ( Adapter ): \"\"\"Encodes and decodes program instructions.\"\"\" def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . ix_layout = _parse_ix_layout ( idl ) sighasher = _Sighash () sighash_layouts : Dict [ bytes , Construct ] = {} sighashes : Dict [ str , bytes ] = {} sighash_to_name : Dict [ bytes , str ] = {} for ix in idl . instructions : ix_name = snake ( ix . name ) sh = sighasher . build ( ix_name ) sighashes [ ix_name ] = sh sighash_layouts [ sh ] = self . ix_layout [ ix_name ] sighash_to_name [ sh ] = ix_name self . sighash_layouts = sighash_layouts self . sighashes = sighashes self . sighash_to_name = sighash_to_name subcon = Sequence ( \"sighash\" / Bytes ( 8 ), Switch ( lambda this : this . sighash , sighash_layouts ), ) super () . __init__ ( subcon ) # type: ignore def encode ( self , ix_name : str , ix : Dict [ str , Any ]) -> bytes : \"\"\"Encode a program instruction. Args: ix_name: The name of the instruction ix: The data to encode. Returns: The encoded instruction. \"\"\" return self . build ( NamedInstruction ( name = ix_name , data = ix )) def _decode ( self , obj : Tuple [ bytes , Any ], context , path ) -> NamedInstruction : return NamedInstruction ( data = obj [ 1 ], name = self . sighash_to_name [ obj [ 0 ]]) def _encode ( self , obj : NamedInstruction , context : Container , path ) -> Tuple [ bytes , Any ]: return ( self . sighashes [ obj . name ], obj . data )","title":"InstructionCoder"},{"location":"dynamic_client/api_reference/#anchorpy.coder.instruction.InstructionCoder.__init__","text":"Init. Parameters: Name Type Description Default idl Idl The parsed IDL object. required Source code in anchorpy/coder/instruction.py def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . ix_layout = _parse_ix_layout ( idl ) sighasher = _Sighash () sighash_layouts : Dict [ bytes , Construct ] = {} sighashes : Dict [ str , bytes ] = {} sighash_to_name : Dict [ bytes , str ] = {} for ix in idl . instructions : ix_name = snake ( ix . name ) sh = sighasher . build ( ix_name ) sighashes [ ix_name ] = sh sighash_layouts [ sh ] = self . ix_layout [ ix_name ] sighash_to_name [ sh ] = ix_name self . sighash_layouts = sighash_layouts self . sighashes = sighashes self . sighash_to_name = sighash_to_name subcon = Sequence ( \"sighash\" / Bytes ( 8 ), Switch ( lambda this : this . sighash , sighash_layouts ), ) super () . __init__ ( subcon ) # type: ignore","title":"__init__()"},{"location":"dynamic_client/api_reference/#anchorpy.coder.instruction.InstructionCoder.encode","text":"Encode a program instruction. Parameters: Name Type Description Default ix_name str The name of the instruction required ix Dict[str, Any] The data to encode. required Returns: Type Description bytes The encoded instruction. Source code in anchorpy/coder/instruction.py def encode ( self , ix_name : str , ix : Dict [ str , Any ]) -> bytes : \"\"\"Encode a program instruction. Args: ix_name: The name of the instruction ix: The data to encode. Returns: The encoded instruction. \"\"\" return self . build ( NamedInstruction ( name = ix_name , data = ix ))","title":"encode()"},{"location":"dynamic_client/api_reference/#anchorpy.coder.event.EventCoder","text":"Encodes and decodes Anchor events. Source code in anchorpy/coder/event.py class EventCoder ( Adapter ): \"\"\"Encodes and decodes Anchor events.\"\"\" def __init__ ( self , idl : Idl ): \"\"\"Initialize the EventCoder. Args: idl: The parsed Idl object. \"\"\" self . idl = idl idl_events = idl . events layouts : Dict [ str , Construct ] if idl_events : layouts = { event . name : _event_layout ( event , idl ) for event in idl_events } else : layouts = {} self . layouts = layouts self . discriminators : Dict [ bytes , str ] = ( {} if idl_events is None else { _event_discriminator ( event . name ): event . name for event in idl_events } ) self . discriminator_to_layout = { disc : self . layouts [ event_name ] for disc , event_name in self . discriminators . items () } subcon = Sequence ( \"discriminator\" / Bytes ( 8 ), # not base64-encoded here Switch ( lambda this : this . discriminator , self . discriminator_to_layout ), ) super () . __init__ ( subcon ) # type: ignore def _decode ( self , obj : Tuple [ bytes , Any ], context , path ) -> Optional [ Event ]: disc = obj [ 0 ] try : event_name = self . discriminators [ disc ] except KeyError : return None return Event ( data = obj [ 1 ], name = event_name )","title":"EventCoder"},{"location":"dynamic_client/api_reference/#anchorpy.coder.event.EventCoder.__init__","text":"Initialize the EventCoder. Parameters: Name Type Description Default idl Idl The parsed Idl object. required Source code in anchorpy/coder/event.py def __init__ ( self , idl : Idl ): \"\"\"Initialize the EventCoder. Args: idl: The parsed Idl object. \"\"\" self . idl = idl idl_events = idl . events layouts : Dict [ str , Construct ] if idl_events : layouts = { event . name : _event_layout ( event , idl ) for event in idl_events } else : layouts = {} self . layouts = layouts self . discriminators : Dict [ bytes , str ] = ( {} if idl_events is None else { _event_discriminator ( event . name ): event . name for event in idl_events } ) self . discriminator_to_layout = { disc : self . layouts [ event_name ] for disc , event_name in self . discriminators . items () } subcon = Sequence ( \"discriminator\" / Bytes ( 8 ), # not base64-encoded here Switch ( lambda this : this . discriminator , self . discriminator_to_layout ), ) super () . __init__ ( subcon ) # type: ignore","title":"__init__()"},{"location":"dynamic_client/api_reference/#anchorpy.coder.accounts.AccountsCoder","text":"Encodes and decodes account data. Source code in anchorpy/coder/accounts.py class AccountsCoder ( Adapter ): \"\"\"Encodes and decodes account data.\"\"\" def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . _accounts_layout = { acc . name : _typedef_layout ( acc , idl . types , acc . name ) for acc in idl . accounts } self . acc_name_to_discriminator = { acc . name : _account_discriminator ( acc . name ) for acc in idl . accounts } self . discriminator_to_acc_name = { disc : acc_name for acc_name , disc in self . acc_name_to_discriminator . items () } discriminator_to_typedef_layout = { disc : self . _accounts_layout [ acc_name ] for acc_name , disc in self . acc_name_to_discriminator . items () } subcon = Sequence ( \"discriminator\" / Bytes ( ACCOUNT_DISCRIMINATOR_SIZE ), Switch ( lambda this : this . discriminator , discriminator_to_typedef_layout ), ) super () . __init__ ( subcon ) # type: ignore def decode ( self , obj : bytes ) -> Container [ Any ]: \"\"\"Decode account data. Args: obj: Data to decode. Returns: Decoded data. \"\"\" return self . parse ( obj ) . data def _decode ( self , obj : Tuple [ bytes , Any ], context , path ) -> AccountToSerialize : return AccountToSerialize ( data = obj [ 1 ], name = self . discriminator_to_acc_name [ obj [ 0 ]], ) def _encode ( self , obj : AccountToSerialize , context , path ) -> Tuple [ bytes , Any ]: discriminator = self . acc_name_to_discriminator [ obj . name ] return discriminator , obj . data","title":"AccountsCoder"},{"location":"dynamic_client/api_reference/#anchorpy.coder.accounts.AccountsCoder.__init__","text":"Init. Parameters: Name Type Description Default idl Idl The parsed IDL object. required Source code in anchorpy/coder/accounts.py def __init__ ( self , idl : Idl ) -> None : \"\"\"Init. Args: idl: The parsed IDL object. \"\"\" self . _accounts_layout = { acc . name : _typedef_layout ( acc , idl . types , acc . name ) for acc in idl . accounts } self . acc_name_to_discriminator = { acc . name : _account_discriminator ( acc . name ) for acc in idl . accounts } self . discriminator_to_acc_name = { disc : acc_name for acc_name , disc in self . acc_name_to_discriminator . items () } discriminator_to_typedef_layout = { disc : self . _accounts_layout [ acc_name ] for acc_name , disc in self . acc_name_to_discriminator . items () } subcon = Sequence ( \"discriminator\" / Bytes ( ACCOUNT_DISCRIMINATOR_SIZE ), Switch ( lambda this : this . discriminator , discriminator_to_typedef_layout ), ) super () . __init__ ( subcon ) # type: ignore","title":"__init__()"},{"location":"dynamic_client/api_reference/#anchorpy.coder.accounts.AccountsCoder.decode","text":"Decode account data. Parameters: Name Type Description Default obj bytes Data to decode. required Returns: Type Description construct.lib.containers.Container[Any] Decoded data. Source code in anchorpy/coder/accounts.py def decode ( self , obj : bytes ) -> Container [ Any ]: \"\"\"Decode account data. Args: obj: Data to decode. Returns: Decoded data. \"\"\" return self . parse ( obj ) . data","title":"decode()"},{"location":"dynamic_client/api_reference/#anchorpy.program.common.NamedInstruction","text":"Container for a named instruction. Attributes: Name Type Description data Union[Dict[str, Any], construct.lib.containers.Container[Any]] The actual instruction data. name str The name of the instruction. Source code in anchorpy/program/common.py @dataclass class NamedInstruction : \"\"\"Container for a named instruction. Attributes: data: The actual instruction data. name: The name of the instruction. \"\"\" data : Union [ Dict [ str , Any ], Container [ Any ]] name : str","title":"NamedInstruction"},{"location":"dynamic_client/api_reference/#anchorpy.idl.IdlProgramAccount","text":"The on-chain account of the IDL. Source code in anchorpy/idl.py class IdlProgramAccount ( TypedDict ): \"\"\"The on-chain account of the IDL.\"\"\" authority : solders . pubkey . Pubkey data : bytes","title":"IdlProgramAccount"},{"location":"dynamic_client/api_reference/#anchorpy.program.common.Event","text":"A parsed event object. Source code in anchorpy/program/common.py class Event ( NamedTuple ): \"\"\"A parsed event object.\"\"\" name : str data : Any","title":"Event"},{"location":"dynamic_client/api_reference/#anchorpy.program.common.translate_address","text":"Convert str | Pubkey into Pubkey . Parameters: Name Type Description Default address Union[solders.pubkey.Pubkey, str] Public key as string or Pubkey . required Returns: Type Description Pubkey Public key as Pubkey . Source code in anchorpy/program/common.py def translate_address ( address : AddressType ) -> Pubkey : \"\"\"Convert `str | Pubkey` into `Pubkey`. Args: address: Public key as string or `Pubkey`. Returns: Public key as `Pubkey`. \"\"\" if isinstance ( address , str ): return Pubkey . from_string ( address ) return address","title":"translate_address()"},{"location":"dynamic_client/api_reference/#anchorpy.program.common.validate_accounts","text":"Check that accounts passed in ctx match the IDL. Parameters: Name Type Description Default ix_accounts list[Union[anchorpy_core.idl.IdlAccount, anchorpy_core.idl.IdlAccounts]] Accounts from the IDL. required accounts Dict[str, Any] Accounts from the ctx arg. required Exceptions: Type Description ValueError If ctx accounts don't match the IDL. Source code in anchorpy/program/common.py def validate_accounts ( ix_accounts : list [ IdlAccountItem ], accounts : Accounts ): \"\"\"Check that accounts passed in `ctx` match the IDL. Args: ix_accounts: Accounts from the IDL. accounts: Accounts from the `ctx` arg. Raises: ValueError: If `ctx` accounts don't match the IDL. \"\"\" for acc in ix_accounts : acc_name = snake ( acc . name ) if isinstance ( acc , IdlAccounts ): nested = cast ( Accounts , accounts [ acc_name ]) validate_accounts ( acc . accounts , nested ) elif acc_name not in accounts : raise ValueError ( f \"Invalid arguments: { acc_name } not provided\" )","title":"validate_accounts()"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.AccountClient","text":"Provides methods for fetching and creating accounts. Source code in anchorpy/program/namespace/account.py class AccountClient ( object ): \"\"\"Provides methods for fetching and creating accounts.\"\"\" def __init__ ( self , idl : Idl , idl_account : IdlTypeDefinition , coder : Coder , program_id : Pubkey , provider : Provider , ): \"\"\"Init. Args: idl: the parsed IDL object. idl_account: the account definition from the IDL. coder: The program's Coder object. program_id: the program ID. provider: The Provider object for the Program. \"\"\" self . _idl_account = idl_account self . _program_id = program_id self . _provider = provider self . _coder = coder self . _size = ACCOUNT_DISCRIMINATOR_SIZE + _account_size ( idl , idl_account ) async def fetch ( self , address : Pubkey , commitment : Optional [ Commitment ] = None ) -> Container [ Any ]: \"\"\"Return a deserialized account. Args: address: The address of the account to fetch. commitment: Bank state to query. Raises: AccountDoesNotExistError: If the account doesn't exist. AccountInvalidDiscriminator: If the discriminator doesn't match the IDL. \"\"\" account_info = await self . _provider . connection . get_account_info ( address , encoding = \"base64\" , commitment = commitment , ) if not account_info . value : raise AccountDoesNotExistError ( f \"Account { address } does not exist\" ) data = account_info . value . data discriminator = _account_discriminator ( self . _idl_account . name ) if discriminator != data [: ACCOUNT_DISCRIMINATOR_SIZE ]: msg = f \"Account { address } has an invalid discriminator\" raise AccountInvalidDiscriminator ( msg ) return self . _coder . accounts . decode ( data ) async def fetch_multiple ( self , addresses : List [ Pubkey ], batch_size : int = 300 , commitment : Optional [ Commitment ] = None , ) -> list [ Optional [ Container [ Any ]]]: \"\"\"Return multiple deserialized accounts. Accounts not found or with wrong discriminator are returned as None. Args: addresses: The addresses of the accounts to fetch. batch_size: The number of `getMultipleAccounts` objects to send in each HTTP request. commitment: Bank state to query. \"\"\" accounts = await get_multiple_accounts ( self . _provider . connection , addresses , batch_size = batch_size , commitment = commitment , ) discriminator = _account_discriminator ( self . _idl_account . name ) result : list [ Optional [ Container [ Any ]]] = [] for account in accounts : if account is None : result . append ( None ) elif discriminator == account . account . data [: 8 ]: result . append ( self . _coder . accounts . decode ( account . account . data )) else : result . append ( None ) return result async def create_instruction ( self , signer : Keypair , size_override : int = 0 , ) -> Instruction : \"\"\"Return an instruction for creating this account. Args: signer: [description] size_override: Optional override for the account size. Defaults to 0. Returns: The instruction to create the account. \"\"\" space = size_override if size_override else self . _size mbre_resp = ( await self . _provider . connection . get_minimum_balance_for_rent_exemption ( space ) ) return create_account ( CreateAccountParams ( from_pubkey = self . _provider . wallet . public_key , to_pubkey = signer . pubkey (), space = space , lamports = mbre_resp . value , owner = self . _program_id , ) ) async def all ( # noqa: A003 self , buffer : Optional [ bytes ] = None , filters : Optional [ List [ Union [ int , MemcmpOpts ]]] = None , ) -> list [ ProgramAccount ]: \"\"\"Return all instances of this account type for the program. Args: buffer: bytes filter to append to the discriminator. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" all_accounts = [] discriminator = _account_discriminator ( self . _idl_account . name ) to_encode = discriminator if buffer is None else discriminator + buffer bytes_arg = b58encode ( to_encode ) . decode ( \"ascii\" ) base_memcmp_opt = MemcmpOpts ( offset = 0 , bytes = bytes_arg , ) filters_to_use = [ base_memcmp_opt ] + ([] if filters is None else filters ) resp = await self . _provider . connection . get_program_accounts ( self . _program_id , encoding = \"base64\" , commitment = self . provider . connection . _commitment , filters = filters_to_use , ) for r in resp . value : account_data = r . account . data all_accounts . append ( ProgramAccount ( public_key = r . pubkey , account = self . _coder . accounts . decode ( account_data ), ), ) return all_accounts @property def size ( self ) -> int : \"\"\"Return the number of bytes in this account.\"\"\" return self . _size @property def program_id ( self ) -> Pubkey : \"\"\"Return the program ID owning all accounts.\"\"\" return self . _program_id @property def provider ( self ) -> Provider : \"\"\"Return the client's wallet and network provider.\"\"\" return self . _provider @property def coder ( self ) -> Coder : \"\"\"Return the coder.\"\"\" return self . _coder","title":"AccountClient"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.AccountClient.coder","text":"Return the coder.","title":"coder"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.AccountClient.program_id","text":"Return the program ID owning all accounts.","title":"program_id"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.AccountClient.provider","text":"Return the client's wallet and network provider.","title":"provider"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.AccountClient.size","text":"Return the number of bytes in this account.","title":"size"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.AccountClient.__init__","text":"Init. Parameters: Name Type Description Default idl Idl the parsed IDL object. required idl_account IdlTypeDefinition the account definition from the IDL. required coder Coder The program's Coder object. required program_id Pubkey the program ID. required provider Provider The Provider object for the Program. required Source code in anchorpy/program/namespace/account.py def __init__ ( self , idl : Idl , idl_account : IdlTypeDefinition , coder : Coder , program_id : Pubkey , provider : Provider , ): \"\"\"Init. Args: idl: the parsed IDL object. idl_account: the account definition from the IDL. coder: The program's Coder object. program_id: the program ID. provider: The Provider object for the Program. \"\"\" self . _idl_account = idl_account self . _program_id = program_id self . _provider = provider self . _coder = coder self . _size = ACCOUNT_DISCRIMINATOR_SIZE + _account_size ( idl , idl_account )","title":"__init__()"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.AccountClient.all","text":"Return all instances of this account type for the program. Parameters: Name Type Description Default buffer Optional[bytes] bytes filter to append to the discriminator. None filters Optional[List[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Source code in anchorpy/program/namespace/account.py async def all ( # noqa: A003 self , buffer : Optional [ bytes ] = None , filters : Optional [ List [ Union [ int , MemcmpOpts ]]] = None , ) -> list [ ProgramAccount ]: \"\"\"Return all instances of this account type for the program. Args: buffer: bytes filter to append to the discriminator. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" all_accounts = [] discriminator = _account_discriminator ( self . _idl_account . name ) to_encode = discriminator if buffer is None else discriminator + buffer bytes_arg = b58encode ( to_encode ) . decode ( \"ascii\" ) base_memcmp_opt = MemcmpOpts ( offset = 0 , bytes = bytes_arg , ) filters_to_use = [ base_memcmp_opt ] + ([] if filters is None else filters ) resp = await self . _provider . connection . get_program_accounts ( self . _program_id , encoding = \"base64\" , commitment = self . provider . connection . _commitment , filters = filters_to_use , ) for r in resp . value : account_data = r . account . data all_accounts . append ( ProgramAccount ( public_key = r . pubkey , account = self . _coder . accounts . decode ( account_data ), ), ) return all_accounts","title":"all()"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.AccountClient.create_instruction","text":"Return an instruction for creating this account. Parameters: Name Type Description Default signer Keypair [description] required size_override int Optional override for the account size. Defaults to 0. 0 Returns: Type Description Instruction The instruction to create the account. Source code in anchorpy/program/namespace/account.py async def create_instruction ( self , signer : Keypair , size_override : int = 0 , ) -> Instruction : \"\"\"Return an instruction for creating this account. Args: signer: [description] size_override: Optional override for the account size. Defaults to 0. Returns: The instruction to create the account. \"\"\" space = size_override if size_override else self . _size mbre_resp = ( await self . _provider . connection . get_minimum_balance_for_rent_exemption ( space ) ) return create_account ( CreateAccountParams ( from_pubkey = self . _provider . wallet . public_key , to_pubkey = signer . pubkey (), space = space , lamports = mbre_resp . value , owner = self . _program_id , ) )","title":"create_instruction()"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.AccountClient.fetch","text":"Return a deserialized account. Parameters: Name Type Description Default address Pubkey The address of the account to fetch. required commitment Optional[solana.rpc.commitment.Commitment] Bank state to query. None Exceptions: Type Description AccountDoesNotExistError If the account doesn't exist. AccountInvalidDiscriminator If the discriminator doesn't match the IDL. Source code in anchorpy/program/namespace/account.py async def fetch ( self , address : Pubkey , commitment : Optional [ Commitment ] = None ) -> Container [ Any ]: \"\"\"Return a deserialized account. Args: address: The address of the account to fetch. commitment: Bank state to query. Raises: AccountDoesNotExistError: If the account doesn't exist. AccountInvalidDiscriminator: If the discriminator doesn't match the IDL. \"\"\" account_info = await self . _provider . connection . get_account_info ( address , encoding = \"base64\" , commitment = commitment , ) if not account_info . value : raise AccountDoesNotExistError ( f \"Account { address } does not exist\" ) data = account_info . value . data discriminator = _account_discriminator ( self . _idl_account . name ) if discriminator != data [: ACCOUNT_DISCRIMINATOR_SIZE ]: msg = f \"Account { address } has an invalid discriminator\" raise AccountInvalidDiscriminator ( msg ) return self . _coder . accounts . decode ( data )","title":"fetch()"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.AccountClient.fetch_multiple","text":"Return multiple deserialized accounts. Accounts not found or with wrong discriminator are returned as None. Parameters: Name Type Description Default addresses List[solders.pubkey.Pubkey] The addresses of the accounts to fetch. required batch_size int The number of getMultipleAccounts objects to send in each HTTP request. 300 commitment Optional[solana.rpc.commitment.Commitment] Bank state to query. None Source code in anchorpy/program/namespace/account.py async def fetch_multiple ( self , addresses : List [ Pubkey ], batch_size : int = 300 , commitment : Optional [ Commitment ] = None , ) -> list [ Optional [ Container [ Any ]]]: \"\"\"Return multiple deserialized accounts. Accounts not found or with wrong discriminator are returned as None. Args: addresses: The addresses of the accounts to fetch. batch_size: The number of `getMultipleAccounts` objects to send in each HTTP request. commitment: Bank state to query. \"\"\" accounts = await get_multiple_accounts ( self . _provider . connection , addresses , batch_size = batch_size , commitment = commitment , ) discriminator = _account_discriminator ( self . _idl_account . name ) result : list [ Optional [ Container [ Any ]]] = [] for account in accounts : if account is None : result . append ( None ) elif discriminator == account . account . data [: 8 ]: result . append ( self . _coder . accounts . decode ( account . account . data )) else : result . append ( None ) return result","title":"fetch_multiple()"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.account.ProgramAccount","text":"Deserialized account owned by a program. Source code in anchorpy/program/namespace/account.py @dataclass class ProgramAccount : \"\"\"Deserialized account owned by a program.\"\"\" public_key : Pubkey account : Container","title":"ProgramAccount"},{"location":"dynamic_client/api_reference/#anchorpy.program.event.EventParser","text":"Parser to handle on_logs callbacks. Source code in anchorpy/program/event.py @dataclass class EventParser : \"\"\"Parser to handle on_logs callbacks.\"\"\" program_id : Pubkey coder : Coder def parse_logs ( self , logs : List [ str ], callback : Callable [[ Event ], None ]) -> None : \"\"\"Parse a list of logs using a provided callback. Args: logs: The logs to parse. callback: The function to handle the parsed log. \"\"\" log_scanner = _LogScanner ( logs ) execution = _ExecutionContext ( cast ( str , log_scanner . to_next ())) log = log_scanner . to_next () while log is not None : event , new_program , did_pop = self . handle_log ( execution , log ) if event is not None : callback ( event ) if new_program is not None : execution . push ( new_program ) if did_pop : execution . pop () log = log_scanner . to_next () def handle_log ( self , execution : _ExecutionContext , log : str , ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Main log handler. Args: execution: The execution stack. log: log string from the RPC node. Returns: A three element array of the event, the next program that was invoked for CPI, and a boolean indicating if a program has completed execution (and thus should be popped off the execution stack). \"\"\" # Executing program is this program. if execution . stack and execution . program () == str ( self . program_id ): return self . handle_program_log ( log ) # Executing program is not this program. return ( None , * self . handle_system_log ( log )) def handle_program_log ( self , log : str ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Handle logs from *this* program. Args: log: log string from the RPC node. \"\"\" # This is a `msg!` log or a `sol_log_data!` log. if log . startswith ( PROGRAM_LOG ) or log . startswith ( PROGRAM_DATA ): log_str = ( log [ PROGRAM_LOG_START_INDEX :] if log . startswith ( PROGRAM_LOG ) else log [ PROGRAM_DATA_START_INDEX :] ) try : decoded = b64decode ( log_str ) except binascii . Error : return None , None , False event = self . coder . events . parse ( decoded ) return event , None , False return ( None , * self . handle_system_log ( log )) def handle_system_log ( self , log : str ) -> tuple [ Optional [ str ], bool ]: \"\"\"Handle logs when the current program being executing is *not* this. Args: log: log string from the RPC node. \"\"\" log_start = log . split ( \":\" )[ 0 ] splitted = log_start . split ( \" \" ) invoke_msg = f \"Program { str ( self . program_id ) } invoke\" if len ( splitted ) == 3 and splitted [ 0 ] == \"Program\" and splitted [ 2 ] == \"success\" : return None , True if log_start . startswith ( invoke_msg ): return str ( self . program_id ), False if \"invoke\" in log_start : return \"cpi\" , False return None , False","title":"EventParser"},{"location":"dynamic_client/api_reference/#anchorpy.program.event.EventParser.handle_log","text":"Main log handler. Parameters: Name Type Description Default execution _ExecutionContext The execution stack. required log str log string from the RPC node. required Returns: Type Description tuple[Optional[anchorpy.program.common.Event], Optional[str], bool] A three element array of the event, the next program that was invoked for CPI, and a boolean indicating if a program has completed execution (and thus should be popped off the execution stack). Source code in anchorpy/program/event.py def handle_log ( self , execution : _ExecutionContext , log : str , ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Main log handler. Args: execution: The execution stack. log: log string from the RPC node. Returns: A three element array of the event, the next program that was invoked for CPI, and a boolean indicating if a program has completed execution (and thus should be popped off the execution stack). \"\"\" # Executing program is this program. if execution . stack and execution . program () == str ( self . program_id ): return self . handle_program_log ( log ) # Executing program is not this program. return ( None , * self . handle_system_log ( log ))","title":"handle_log()"},{"location":"dynamic_client/api_reference/#anchorpy.program.event.EventParser.handle_program_log","text":"Handle logs from this program. Parameters: Name Type Description Default log str log string from the RPC node. required Source code in anchorpy/program/event.py def handle_program_log ( self , log : str ) -> tuple [ Optional [ Event ], Optional [ str ], bool ]: \"\"\"Handle logs from *this* program. Args: log: log string from the RPC node. \"\"\" # This is a `msg!` log or a `sol_log_data!` log. if log . startswith ( PROGRAM_LOG ) or log . startswith ( PROGRAM_DATA ): log_str = ( log [ PROGRAM_LOG_START_INDEX :] if log . startswith ( PROGRAM_LOG ) else log [ PROGRAM_DATA_START_INDEX :] ) try : decoded = b64decode ( log_str ) except binascii . Error : return None , None , False event = self . coder . events . parse ( decoded ) return event , None , False return ( None , * self . handle_system_log ( log ))","title":"handle_program_log()"},{"location":"dynamic_client/api_reference/#anchorpy.program.event.EventParser.handle_system_log","text":"Handle logs when the current program being executing is not this. Parameters: Name Type Description Default log str log string from the RPC node. required Source code in anchorpy/program/event.py def handle_system_log ( self , log : str ) -> tuple [ Optional [ str ], bool ]: \"\"\"Handle logs when the current program being executing is *not* this. Args: log: log string from the RPC node. \"\"\" log_start = log . split ( \":\" )[ 0 ] splitted = log_start . split ( \" \" ) invoke_msg = f \"Program { str ( self . program_id ) } invoke\" if len ( splitted ) == 3 and splitted [ 0 ] == \"Program\" and splitted [ 2 ] == \"success\" : return None , True if log_start . startswith ( invoke_msg ): return str ( self . program_id ), False if \"invoke\" in log_start : return \"cpi\" , False return None , False","title":"handle_system_log()"},{"location":"dynamic_client/api_reference/#anchorpy.program.event.EventParser.parse_logs","text":"Parse a list of logs using a provided callback. Parameters: Name Type Description Default logs List[str] The logs to parse. required callback Callable[[anchorpy.program.common.Event], NoneType] The function to handle the parsed log. required Source code in anchorpy/program/event.py def parse_logs ( self , logs : List [ str ], callback : Callable [[ Event ], None ]) -> None : \"\"\"Parse a list of logs using a provided callback. Args: logs: The logs to parse. callback: The function to handle the parsed log. \"\"\" log_scanner = _LogScanner ( logs ) execution = _ExecutionContext ( cast ( str , log_scanner . to_next ())) log = log_scanner . to_next () while log is not None : event , new_program , did_pop = self . handle_log ( execution , log ) if event is not None : callback ( event ) if new_program is not None : execution . push ( new_program ) if did_pop : execution . pop () log = log_scanner . to_next ()","title":"parse_logs()"},{"location":"dynamic_client/api_reference/#anchorpy.program.namespace.simulate.SimulateResponse","text":"The result of a simulate function call. Source code in anchorpy/program/namespace/simulate.py class SimulateResponse ( NamedTuple ): \"\"\"The result of a simulate function call.\"\"\" events : list [ Event ] raw : list [ str ]","title":"SimulateResponse"},{"location":"dynamic_client/api_reference/#anchorpy.error","text":"This module handles AnchorPy errors.","title":"error"},{"location":"dynamic_client/api_reference/#anchorpy.error.AccountDoesNotExistError","text":"Raise if account doesn't exist. Source code in anchorpy/error.py class AccountDoesNotExistError ( Exception ): \"\"\"Raise if account doesn't exist.\"\"\"","title":"AccountDoesNotExistError"},{"location":"dynamic_client/api_reference/#anchorpy.error.AccountInvalidDiscriminator","text":"Raise if account discriminator doesn't match the IDL. Source code in anchorpy/error.py class AccountInvalidDiscriminator ( Exception ): \"\"\"Raise if account discriminator doesn't match the IDL.\"\"\"","title":"AccountInvalidDiscriminator"},{"location":"dynamic_client/api_reference/#anchorpy.error.ArgsError","text":"Raise when the incorrect number of args is passed to the RPC function. Source code in anchorpy/error.py class ArgsError ( Exception ): \"\"\"Raise when the incorrect number of args is passed to the RPC function.\"\"\"","title":"ArgsError"},{"location":"dynamic_client/api_reference/#anchorpy.error.IdlNotFoundError","text":"Raise when requested IDL account does not exist. Source code in anchorpy/error.py class IdlNotFoundError ( Exception ): \"\"\"Raise when requested IDL account does not exist.\"\"\"","title":"IdlNotFoundError"},{"location":"dynamic_client/api_reference/#anchorpy.error.ProgramError","text":"An error from a user defined program. Source code in anchorpy/error.py class ProgramError ( Exception ): \"\"\"An error from a user defined program.\"\"\" def __init__ ( self , code : int , msg : Optional [ str ], logs : Optional [ list [ str ]] = None ) -> None : \"\"\"Init. Args: code: The error code. msg: The error message. logs: The transaction simulation logs. \"\"\" self . code = code self . msg = msg self . logs = logs super () . __init__ ( f \" { code } : { msg } \" ) @classmethod def parse ( cls , err_info : RPCError , idl_errors : dict [ int , str ], program_id : Pubkey , ) -> Optional [ ProgramError ]: \"\"\"Convert an RPC error into a ProgramError, if possible. Args: err_info: The RPC error. idl_errors: Errors from the IDL file. program_id: The ID of the program we expect the error to come from. Returns: A ProgramError or None. \"\"\" extracted = extract_code_and_logs ( err_info , program_id ) if extracted is None : return None code , logs = extracted msg = idl_errors . get ( code ) if msg is not None : return cls ( code , msg , logs ) # parse framework internal error msg = LangErrorMessage . get ( code ) if msg is not None : return cls ( code , msg , logs ) # Unable to parse the error. return None @classmethod def parse_tx_error ( cls , err_info : TransactionErrorType , idl_errors : dict [ int , str ], program_id : Pubkey , logs : List [ str ], ) -> Optional [ ProgramError ]: \"\"\"Convert an RPC error into a ProgramError, if possible. Args: err_info: The RPC error. idl_errors: Errors from the IDL file. program_id: The ID of the program we expect the error to come from. logs: The transaction logs. Returns: A ProgramError or None. \"\"\" code = extract_code_tx_error ( err_info , program_id , logs ) if code is None : return None msg = idl_errors . get ( code ) if msg is not None : return cls ( code , msg , logs ) # parse framework internal error msg = LangErrorMessage . get ( code ) if msg is not None : return cls ( code , msg , logs ) # Unable to parse the error. return None","title":"ProgramError"},{"location":"dynamic_client/api_reference/#anchorpy.error.ProgramError.__init__","text":"Init. Parameters: Name Type Description Default code int The error code. required msg Optional[str] The error message. required logs Optional[list[str]] The transaction simulation logs. None Source code in anchorpy/error.py def __init__ ( self , code : int , msg : Optional [ str ], logs : Optional [ list [ str ]] = None ) -> None : \"\"\"Init. Args: code: The error code. msg: The error message. logs: The transaction simulation logs. \"\"\" self . code = code self . msg = msg self . logs = logs super () . __init__ ( f \" { code } : { msg } \" )","title":"__init__()"},{"location":"dynamic_client/api_reference/#anchorpy.error.ProgramError.parse","text":"Convert an RPC error into a ProgramError, if possible. Parameters: Name Type Description Default err_info RPCError The RPC error. required idl_errors dict[int, str] Errors from the IDL file. required program_id Pubkey The ID of the program we expect the error to come from. required Returns: Type Description Optional[ProgramError] A ProgramError or None. Source code in anchorpy/error.py @classmethod def parse ( cls , err_info : RPCError , idl_errors : dict [ int , str ], program_id : Pubkey , ) -> Optional [ ProgramError ]: \"\"\"Convert an RPC error into a ProgramError, if possible. Args: err_info: The RPC error. idl_errors: Errors from the IDL file. program_id: The ID of the program we expect the error to come from. Returns: A ProgramError or None. \"\"\" extracted = extract_code_and_logs ( err_info , program_id ) if extracted is None : return None code , logs = extracted msg = idl_errors . get ( code ) if msg is not None : return cls ( code , msg , logs ) # parse framework internal error msg = LangErrorMessage . get ( code ) if msg is not None : return cls ( code , msg , logs ) # Unable to parse the error. return None","title":"parse()"},{"location":"dynamic_client/api_reference/#anchorpy.error.ProgramError.parse_tx_error","text":"Convert an RPC error into a ProgramError, if possible. Parameters: Name Type Description Default err_info TransactionErrorType The RPC error. required idl_errors dict[int, str] Errors from the IDL file. required program_id Pubkey The ID of the program we expect the error to come from. required logs List[str] The transaction logs. required Returns: Type Description Optional[ProgramError] A ProgramError or None. Source code in anchorpy/error.py @classmethod def parse_tx_error ( cls , err_info : TransactionErrorType , idl_errors : dict [ int , str ], program_id : Pubkey , logs : List [ str ], ) -> Optional [ ProgramError ]: \"\"\"Convert an RPC error into a ProgramError, if possible. Args: err_info: The RPC error. idl_errors: Errors from the IDL file. program_id: The ID of the program we expect the error to come from. logs: The transaction logs. Returns: A ProgramError or None. \"\"\" code = extract_code_tx_error ( err_info , program_id , logs ) if code is None : return None msg = idl_errors . get ( code ) if msg is not None : return cls ( code , msg , logs ) # parse framework internal error msg = LangErrorMessage . get ( code ) if msg is not None : return cls ( code , msg , logs ) # Unable to parse the error. return None","title":"parse_tx_error()"},{"location":"dynamic_client/api_reference/#anchorpy.error.extract_code_and_logs","text":"Extract the custom instruction error code from an RPC response. Parameters: Name Type Description Default err_info RPCError The RPC error. required program_id Pubkey The ID of the program we expect the error to come from. required Source code in anchorpy/error.py def extract_code_and_logs ( err_info : RPCError , program_id : Pubkey ) -> Optional [ Tuple [ int , List [ str ]]]: \"\"\"Extract the custom instruction error code from an RPC response. Args: err_info: The RPC error. program_id: The ID of the program we expect the error to come from. \"\"\" if isinstance ( err_info , SendTransactionPreflightFailureMessage ): err_data = err_info . data err_data_err = err_data . err logs = err_data . logs if logs is None : return None if err_data_err is None : return None maybe_code = _handle_ix_err ( err_data_err , logs , program_id ) return None if maybe_code is None else ( maybe_code , logs ) return None","title":"extract_code_and_logs()"},{"location":"dynamic_client/api_reference/#anchorpy.error.extract_code_tx_error","text":"Extract the custom instruction error code from a transaction error. Parameters: Name Type Description Default err_info TransactionErrorType The tx error. required program_id Pubkey The ID of the program we expect the error to come from. required logs List[str] The tx logs. required Source code in anchorpy/error.py def extract_code_tx_error ( err_info : TransactionErrorType , program_id : Pubkey , logs : List [ str ] ) -> Optional [ int ]: \"\"\"Extract the custom instruction error code from a transaction error. Args: err_info: The tx error. program_id: The ID of the program we expect the error to come from. logs: The tx logs. \"\"\" return _handle_ix_err ( err_info , logs , program_id )","title":"extract_code_tx_error()"},{"location":"dynamic_client/api_reference/#anchorpy.utils","text":"Various utility functions.","title":"utils"},{"location":"dynamic_client/api_reference/#anchorpy.utils.rpc","text":"This module contains the invoke function.","title":"rpc"},{"location":"dynamic_client/api_reference/#anchorpy.utils.rpc.AccountInfo","text":"Information describing an account. Attributes: Name Type Description executable bool True if this account's data contains a loaded program. owner Pubkey Identifier of the program that owns the account. lamports int Number of lamports assigned to the account. data bytes Optional data assigned to the account. rent_epoch Optional[int] Optional rent epoch info for for account. Source code in anchorpy/utils/rpc.py class AccountInfo ( NamedTuple ): \"\"\"Information describing an account. Attributes: executable: `True` if this account's data contains a loaded program. owner: Identifier of the program that owns the account. lamports: Number of lamports assigned to the account. data: Optional data assigned to the account. rent_epoch: Optional rent epoch info for for account. \"\"\" executable : bool owner : Pubkey lamports : int data : bytes rent_epoch : Optional [ int ]","title":"AccountInfo"},{"location":"dynamic_client/api_reference/#anchorpy.utils.rpc.get_multiple_accounts","text":"Fetch multiple account infos through batched getMultipleAccount RPC requests. Parameters: Name Type Description Default connection AsyncClient The solana-py client object. required pubkeys list[solders.pubkey.Pubkey] Pubkeys to fetch. required batch_size int The number of getMultipleAccount objects to include in each HTTP request. 3 commitment Optional[solana.rpc.commitment.Commitment] Bank state to query. None Returns: Type Description list[Optional[anchorpy.utils.rpc._MultipleAccountsItem]] Account infos and pubkeys. Source code in anchorpy/utils/rpc.py async def get_multiple_accounts ( connection : AsyncClient , pubkeys : list [ Pubkey ], batch_size : int = 3 , commitment : Optional [ Commitment ] = None , ) -> list [ Optional [ _MultipleAccountsItem ]]: \"\"\"Fetch multiple account infos through batched `getMultipleAccount` RPC requests. Args: connection: The `solana-py` client object. pubkeys: Pubkeys to fetch. batch_size: The number of `getMultipleAccount` objects to include in each HTTP request. commitment: Bank state to query. Returns: Account infos and pubkeys. \"\"\" pubkeys_per_network_request = _GET_MULTIPLE_ACCOUNTS_LIMIT * batch_size chunks = partition_all ( pubkeys_per_network_request , pubkeys ) awaitables = [ _get_multiple_accounts_core ( connection , pubkeys_chunk , commitment ) for pubkeys_chunk in chunks ] results = await gather ( * awaitables , return_exceptions = False ) return list ( concat ( results ))","title":"get_multiple_accounts()"},{"location":"dynamic_client/api_reference/#anchorpy.utils.token","text":"This module contains utilities for the SPL Token Program.","title":"token"},{"location":"dynamic_client/api_reference/#anchorpy.utils.token.create_mint_and_vault","text":"Create a mint and a vault, then mint tokens to the vault. Parameters: Name Type Description Default provider Provider An anchorpy Provider instance. required amount int The amount of tokens to mint to the vault. required owner Optional[solders.pubkey.Pubkey] User account that will own the new account. None decimals Optional[int] The number of decimal places for the token to support. None Returns: Type Description tuple[solders.pubkey.Pubkey, solders.pubkey.Pubkey] The mint and vault pubkeys. Source code in anchorpy/utils/token.py async def create_mint_and_vault ( provider : Provider , amount : int , owner : Optional [ Pubkey ] = None , decimals : Optional [ int ] = None , ) -> tuple [ Pubkey , Pubkey ]: \"\"\"Create a mint and a vault, then mint tokens to the vault. Args: provider: An anchorpy Provider instance. amount: The amount of tokens to mint to the vault. owner: User account that will own the new account. decimals: The number of decimal places for the token to support. Returns: The mint and vault pubkeys. \"\"\" actual_owner = provider . wallet . public_key if owner is None else owner mint = Keypair () vault = Keypair () mint_space = 82 create_mint_mbre_resp = ( await provider . connection . get_minimum_balance_for_rent_exemption ( mint_space ) ) create_mint_mbre = create_mint_mbre_resp . value create_mint_account_params = CreateAccountParams ( from_pubkey = provider . wallet . public_key , to_pubkey = mint . pubkey (), space = mint_space , lamports = create_mint_mbre , owner = TOKEN_PROGRAM_ID , ) create_mint_account_instruction = create_account ( create_mint_account_params , ) init_mint_instruction = initialize_mint ( InitializeMintParams ( mint = mint . pubkey (), decimals = 0 if decimals is None else decimals , mint_authority = provider . wallet . public_key , program_id = TOKEN_PROGRAM_ID , ), ) vault_space = 165 create_vault_mbre_resp = ( await provider . connection . get_minimum_balance_for_rent_exemption ( vault_space ) ) create_vault_mbre = create_vault_mbre_resp . value create_vault_account_instruction = create_account ( CreateAccountParams ( from_pubkey = provider . wallet . public_key , to_pubkey = vault . pubkey (), space = vault_space , lamports = create_vault_mbre , owner = TOKEN_PROGRAM_ID , ), ) init_vault_instruction = initialize_account ( InitializeAccountParams ( program_id = TOKEN_PROGRAM_ID , account = vault . pubkey (), mint = mint . pubkey (), owner = actual_owner , ), ) mint_to_instruction = mint_to ( MintToParams ( program_id = TOKEN_PROGRAM_ID , mint = mint . pubkey (), dest = vault . pubkey (), amount = amount , mint_authority = provider . wallet . public_key , ), ) blockhash = ( await provider . connection . get_latest_blockhash ( Confirmed ) ) . value . blockhash msg = Message . new_with_blockhash ( [ create_mint_account_instruction , init_mint_instruction , create_vault_account_instruction , init_vault_instruction , mint_to_instruction , ], provider . wallet . public_key , blockhash , ) tx = VersionedTransaction ( msg , [ provider . wallet . payer , mint , vault ]) await provider . send ( tx ) return mint . pubkey (), vault . pubkey ()","title":"create_mint_and_vault()"},{"location":"dynamic_client/api_reference/#anchorpy.utils.token.create_token_account","text":"Create a token account. Parameters: Name Type Description Default prov Provider An anchorpy Provider instance. required mint Pubkey The pubkey of the token's mint. required owner Pubkey User account that will own the new account. required Returns: Type Description Pubkey The pubkey of the new account. Source code in anchorpy/utils/token.py async def create_token_account ( prov : Provider , mint : Pubkey , owner : Pubkey , ) -> Pubkey : \"\"\"Create a token account. Args: prov: An anchorpy Provider instance. mint: The pubkey of the token's mint. owner: User account that will own the new account. Returns: The pubkey of the new account. \"\"\" token = AsyncToken ( prov . connection , mint , TOKEN_PROGRAM_ID , prov . wallet . payer ) return await token . create_account ( owner )","title":"create_token_account()"},{"location":"dynamic_client/api_reference/#anchorpy.utils.token.create_token_account_instrs","text":"Generate instructions for creating a token account. Parameters: Name Type Description Default provider Provider An anchorpy Provider instance. required new_account_pubkey Pubkey The pubkey of the new account. required mint Pubkey The pubkey of the token's mint. required owner Pubkey User account that will own the new account. required Returns: Type Description tuple[solders.instruction.Instruction, solders.instruction.Instruction] Transaction instructions to create the new account. Source code in anchorpy/utils/token.py async def create_token_account_instrs ( provider : Provider , new_account_pubkey : Pubkey , mint : Pubkey , owner : Pubkey , ) -> tuple [ Instruction , Instruction ]: \"\"\"Generate instructions for creating a token account. Args: provider: An anchorpy Provider instance. new_account_pubkey: The pubkey of the new account. mint: The pubkey of the token's mint. owner: User account that will own the new account. Returns: Transaction instructions to create the new account. \"\"\" mbre_resp = await provider . connection . get_minimum_balance_for_rent_exemption ( 165 ) lamports = mbre_resp . value return ( create_account ( CreateAccountParams ( from_pubkey = provider . wallet . public_key , to_pubkey = new_account_pubkey , space = 165 , lamports = lamports , owner = TOKEN_PROGRAM_ID , ) ), initialize_account ( InitializeAccountParams ( account = new_account_pubkey , mint = mint , owner = owner , program_id = TOKEN_PROGRAM_ID , ) ), )","title":"create_token_account_instrs()"},{"location":"dynamic_client/api_reference/#anchorpy.utils.token.get_mint_info","text":"Retrieve mint information. Parameters: Name Type Description Default provider Provider The anchorpy Provider instance. required addr Pubkey The pubkey of the mint. required Returns: Type Description MintInfo The parsed MintInfo . Source code in anchorpy/utils/token.py async def get_mint_info ( provider : Provider , addr : Pubkey , ) -> MintInfo : \"\"\"Retrieve mint information. Args: provider: The anchorpy Provider instance. addr: The pubkey of the mint. Returns: The parsed `MintInfo`. \"\"\" depositor_acc_info_raw = await provider . connection . get_account_info ( addr ) return parse_mint_account ( depositor_acc_info_raw )","title":"get_mint_info()"},{"location":"dynamic_client/api_reference/#anchorpy.utils.token.get_token_account","text":"Retrieve token account information. Parameters: Name Type Description Default provider Provider The anchorpy Provider instance. required addr Pubkey The pubkey of the token account. required Returns: Type Description AccountInfo The parsed AccountInfo of the token account. Source code in anchorpy/utils/token.py async def get_token_account ( provider : Provider , addr : Pubkey ) -> AccountInfo : \"\"\"Retrieve token account information. Args: provider: The anchorpy Provider instance. addr: The pubkey of the token account. Returns: The parsed `AccountInfo` of the token account. \"\"\" depositor_acc_info_raw = await provider . connection . get_account_info ( addr ) return parse_token_account ( depositor_acc_info_raw )","title":"get_token_account()"},{"location":"dynamic_client/api_reference/#anchorpy.utils.token.parse_mint_account","text":"Parse raw RPC response into MintInfo . Parameters: Name Type Description Default info GetAccountInfoResp The RPC response from calling .get_account_info for the mint pubkey. required Exceptions: Type Description AttributeError If the account is not owned by the Token Program. ValueError If the fetched data is the wrong size. Returns: Type Description MintInfo The parsed MintInfo . Source code in anchorpy/utils/token.py def parse_mint_account ( info : GetAccountInfoResp ) -> MintInfo : \"\"\"Parse raw RPC response into `MintInfo`. Args: info: The RPC response from calling `.get_account_info` for the mint pubkey. Raises: AttributeError: If the account is not owned by the Token Program. ValueError: If the fetched data is the wrong size. Returns: The parsed `MintInfo`. \"\"\" val = info . value if val is None : raise ValueError ( \"Account does not exist.\" ) owner = val . owner if owner != TOKEN_PROGRAM_ID : raise AttributeError ( f \"Invalid mint owner: { owner } \" ) bytes_data = val . data if len ( bytes_data ) != MINT_LAYOUT . sizeof (): raise ValueError ( \"Invalid mint size\" ) decoded_data = MINT_LAYOUT . parse ( bytes_data ) decimals = decoded_data . decimals mint_authority = ( None if decoded_data . mint_authority_option == 0 else Pubkey ( decoded_data . mint_authority ) ) supply = decoded_data . supply is_initialized = decoded_data . is_initialized != 0 if decoded_data . freeze_authority_option == 0 : freeze_authority = None else : freeze_authority = Pubkey ( decoded_data . freeze_authority ) return MintInfo ( mint_authority , supply , decimals , is_initialized , freeze_authority )","title":"parse_mint_account()"},{"location":"dynamic_client/api_reference/#anchorpy.utils.token.parse_token_account","text":"Parse AccountInfo from RPC response. Parameters: Name Type Description Default info GetAccountInfoResp the get_account_info RPC response. required Exceptions: Type Description ValueError If the fetched data is the wrong size. AttributeError If the account is not owned by the token program. Returns: Type Description AccountInfo The parsed AccountInfo . Source code in anchorpy/utils/token.py def parse_token_account ( info : GetAccountInfoResp ) -> AccountInfo : \"\"\"Parse `AccountInfo` from RPC response. Args: info: the `get_account_info` RPC response. Raises: ValueError: If the fetched data is the wrong size. AttributeError: If the account is not owned by the token program. Returns: The parsed `AccountInfo`. \"\"\" val = info . value if not val : raise ValueError ( \"Invalid account owner\" ) if val . owner != TOKEN_PROGRAM_ID : raise AttributeError ( \"Invalid account owner\" ) bytes_data = val . data if len ( bytes_data ) != ACCOUNT_LAYOUT . sizeof (): raise ValueError ( \"Invalid account size\" ) decoded_data = ACCOUNT_LAYOUT . parse ( bytes_data ) mint = Pubkey ( decoded_data . mint ) owner = Pubkey ( decoded_data . owner ) amount = decoded_data . amount if decoded_data . delegate_option == 0 : delegate = None delegated_amount = 0 else : delegate = Pubkey ( decoded_data . delegate ) delegated_amount = decoded_data . delegated_amount is_initialized = decoded_data . state != 0 is_frozen = decoded_data . state == 2 if decoded_data . is_native_option == 1 : rent_exempt_reserve = decoded_data . is_native is_native = True else : rent_exempt_reserve = None is_native = False if decoded_data . close_authority_option == 0 : close_authority = None else : close_authority = Pubkey ( decoded_data . owner ) return AccountInfo ( mint , owner , amount , delegate , delegated_amount , is_initialized , is_frozen , is_native , rent_exempt_reserve , close_authority , )","title":"parse_token_account()"},{"location":"dynamic_client/comparison_with_anchor_ts/","text":"Comparison with Typescript While AnchorPy is quite similar to the Anchor Typescript client, there are some differences: Dictionaries instead of objects AnchorPy tends to use dictionaries, so it uses [key] in some places where anchor-ts would use .key . For example, AnchorPy uses workspace[\"basic_1\"] instead of workspace.basic_1 , and program.rpc[\"initialize\"]() instead of program.rpc.initialize() Explicit Context object AnchorPy uses a Context dataclass and has a ctx keyword argument when calling .rpc functions, whereas Typescript is a bit less structured. We call program.rpc[\"my_func\"](ctx=Context({\"my_account\": my_account})) instead of program.rpc[\"my_func\"]({\"my_account\": my_account}) snake_case \ud83d\udc0d instead of camelCase \ud83d\udc2a AnchorPy uses more snake_case to match Rust and be Pythonic. Specifically, the following names are snake-case in AnchorPy: Workspaces: workspace[\"puppet_master\"] instead of workspace[\"puppetMaster\"] Instructions: program.rpc[\"my_func\"] (and program.instruction[\"my_func\"] ) instead of program.rpc[\"myFunc\"] . Accounts in the ctx arg: {\"my_account\": my_account} instead of {\"myAccount\": my_account} Fields in user-defined types: program.type[\"TransactionAccount\"](is_writable=True) instead of program.type[\"TransactionAccount\"](isWritable=True) program.type namespace for user-defined types The AnchorPy Program object has a .type attribute for instantiating user-defined types. This is not present in the Typescript client. See the examples for more on this.","title":"Comparison with Typescript"},{"location":"dynamic_client/comparison_with_anchor_ts/#comparison-with-typescript","text":"While AnchorPy is quite similar to the Anchor Typescript client, there are some differences:","title":"Comparison with Typescript"},{"location":"dynamic_client/comparison_with_anchor_ts/#dictionaries-instead-of-objects","text":"AnchorPy tends to use dictionaries, so it uses [key] in some places where anchor-ts would use .key . For example, AnchorPy uses workspace[\"basic_1\"] instead of workspace.basic_1 , and program.rpc[\"initialize\"]() instead of program.rpc.initialize()","title":"Dictionaries instead of objects"},{"location":"dynamic_client/comparison_with_anchor_ts/#explicit-context-object","text":"AnchorPy uses a Context dataclass and has a ctx keyword argument when calling .rpc functions, whereas Typescript is a bit less structured. We call program.rpc[\"my_func\"](ctx=Context({\"my_account\": my_account})) instead of program.rpc[\"my_func\"]({\"my_account\": my_account})","title":"Explicit Context object"},{"location":"dynamic_client/comparison_with_anchor_ts/#snake_case-instead-of-camelcase","text":"AnchorPy uses more snake_case to match Rust and be Pythonic. Specifically, the following names are snake-case in AnchorPy: Workspaces: workspace[\"puppet_master\"] instead of workspace[\"puppetMaster\"] Instructions: program.rpc[\"my_func\"] (and program.instruction[\"my_func\"] ) instead of program.rpc[\"myFunc\"] . Accounts in the ctx arg: {\"my_account\": my_account} instead of {\"myAccount\": my_account} Fields in user-defined types: program.type[\"TransactionAccount\"](is_writable=True) instead of program.type[\"TransactionAccount\"](isWritable=True)","title":"snake_case \ud83d\udc0d instead of camelCase \ud83d\udc2a"},{"location":"dynamic_client/comparison_with_anchor_ts/#programtype-namespace-for-user-defined-types","text":"The AnchorPy Program object has a .type attribute for instantiating user-defined types. This is not present in the Typescript client. See the examples for more on this.","title":"program.type namespace for user-defined types"},{"location":"dynamic_client/examples/","text":"Examples Here are some of the other things you can do with AnchorPy: Loading a Program from an on-chain IDL If a program's IDL is stored on-chain, you can use it to initialize a program object using Program.at . import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey from anchorpy import Program , Provider , Wallet async def main (): client = AsyncClient ( \"https://api.mainnet-beta.solana.com/\" ) provider = Provider ( client , Wallet . local ()) # load the Serum Swap Program (not the Serum dex itself). program_id = Pubkey . from_string ( \"22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD\" ) program = await Program . at ( program_id , provider ) print ( program . idl . name ) # swap await program . close () asyncio . run ( main ()) Instantiating user-defined types with program.type Enums Suppose we have an instruction that expects an Enum called Side , with variants Buy and Sell . The Program object has a .type namespace to make it easy to use this enum: await program . rpc [ \"my_func\" ]( program . type [ \"Side\" ] . Buy ()) See test_token_proxy.py for a more concrete example. Structs .type also allows us to build structs defined in the IDL. See this snippet from test_multisig.py : program . type [ \"TransactionAccount\" ]( pubkey = multisig . pubkey (), is_writable = True , is_signer = False , ) Bulk-fetching data with .fetch_multiple You can use .fetch_multiple to get deserialized account data for many accounts at once. Look at this example from test_misc.py : n_accounts = 200 pubkeys = [ initialized_keypair . pubkey ()] * n_accounts # noqa: WPS435 data_accounts = await program . account [ \"Data\" ] . fetch_multiple ( pubkeys , batch_size = 2 ) The above example fetches data for the same pubkey 200 times which is not very interesting, but it could just as easily be fetching 200 different accounts. The .fetch_multiple method uses async batch RPC requests and getMultipleAccounts so it's quite efficient. Warning Be mindful of your RPC provider when fetching data, and plan out how many requests you'll end up sending to the RPC node. You can reliably fetch around 300 public keys in one HTTP request.","title":"Examples"},{"location":"dynamic_client/examples/#examples","text":"Here are some of the other things you can do with AnchorPy:","title":"Examples"},{"location":"dynamic_client/examples/#loading-a-program-from-an-on-chain-idl","text":"If a program's IDL is stored on-chain, you can use it to initialize a program object using Program.at . import asyncio from solana.rpc.async_api import AsyncClient from solders.pubkey import Pubkey from anchorpy import Program , Provider , Wallet async def main (): client = AsyncClient ( \"https://api.mainnet-beta.solana.com/\" ) provider = Provider ( client , Wallet . local ()) # load the Serum Swap Program (not the Serum dex itself). program_id = Pubkey . from_string ( \"22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD\" ) program = await Program . at ( program_id , provider ) print ( program . idl . name ) # swap await program . close () asyncio . run ( main ())","title":"Loading a Program from an on-chain IDL"},{"location":"dynamic_client/examples/#instantiating-user-defined-types-with-programtype","text":"","title":"Instantiating user-defined types with program.type"},{"location":"dynamic_client/examples/#enums","text":"Suppose we have an instruction that expects an Enum called Side , with variants Buy and Sell . The Program object has a .type namespace to make it easy to use this enum: await program . rpc [ \"my_func\" ]( program . type [ \"Side\" ] . Buy ()) See test_token_proxy.py for a more concrete example.","title":"Enums"},{"location":"dynamic_client/examples/#structs","text":".type also allows us to build structs defined in the IDL. See this snippet from test_multisig.py : program . type [ \"TransactionAccount\" ]( pubkey = multisig . pubkey (), is_writable = True , is_signer = False , )","title":"Structs"},{"location":"dynamic_client/examples/#bulk-fetching-data-with-fetch_multiple","text":"You can use .fetch_multiple to get deserialized account data for many accounts at once. Look at this example from test_misc.py : n_accounts = 200 pubkeys = [ initialized_keypair . pubkey ()] * n_accounts # noqa: WPS435 data_accounts = await program . account [ \"Data\" ] . fetch_multiple ( pubkeys , batch_size = 2 ) The above example fetches data for the same pubkey 200 times which is not very interesting, but it could just as easily be fetching 200 different accounts. The .fetch_multiple method uses async batch RPC requests and getMultipleAccounts so it's quite efficient. Warning Be mindful of your RPC provider when fetching data, and plan out how many requests you'll end up sending to the RPC node. You can reliably fetch around 300 public keys in one HTTP request.","title":"Bulk-fetching data with .fetch_multiple"},{"location":"testing/","text":"Testing with AnchorPy Approaches There are two ways to test Anchor programs using AnchorPy: Using the AnchorPy Pytest plugin. Using anchor test and modifying Anchor.toml . 1. Pytest plugin AnchorPy provides a workspace_fixture function that creates a Pytest fixture. This fixture runs anchor localnet in the project root and shuts down the localnet when the tests are done. With this approach you're just running regular Pytest tests. This lets you do some things that you can't do with anchor test , like integrating closely with your IDE or opening a debugger when a test fails ( pytest --pdb ). Here's how it looks with the basic-1 tests: from pytest import fixture , mark from solders.keypair import Keypair from solders.system_program import ID as SYS_PROGRAM_ID from anchorpy import Context , Program , workspace_fixture , WorkspaceType workspace = workspace_fixture ( \"anchor/examples/tutorial/basic-1\" ) # Since our other fixtures have module scope, we need to define # this event_loop fixture and give it module scope otherwise # pytest-asyncio will break. @fixture ( scope = \"module\" ) def event_loop (): \"\"\"Create an instance of the default event loop for each test case.\"\"\" loop = asyncio . get_event_loop_policy () . new_event_loop () yield loop loop . close () @fixture ( scope = \"module\" ) def program ( workspace : WorkspaceType ) -> Program : \"\"\"Create a Program instance.\"\"\" return workspace [ \"basic_1\" ] @fixture ( scope = \"module\" ) async def initialized_account ( program : Program ) -> Keypair : \"\"\"Generate a keypair and initialize it.\"\"\" my_account = Keypair () await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = { \"my_account\" : my_account . pubkey (), \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID , }, signers = [ my_account ], ), ) return my_account @mark . asyncio async def test_create_and_initialize_account ( program : Program , initialized_account : Keypair , ) -> None : \"\"\"Test creating and initializing account in single tx.\"\"\" account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . pubkey ()) assert account . data == 1234 @mark . asyncio async def test_update_previously_created_account ( initialized_account : Keypair , program : Program , ) -> None : \"\"\"Test updating a previously created account.\"\"\" await program . rpc [ \"update\" ]( 4321 , ctx = Context ( accounts = { \"my_account\" : initialized_account . pubkey ()}), ) account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . pubkey ()) assert account . data == 4321 You can just run these tests with pytest (or have your IDE run them). Note There is also a lower-level localnet_fixture function that sets up a localnet for a particular project but doesn't return a workspace. 2. Anchor test Anchor lets you run whatever tests you want using the [scripts] section of Anchor.toml . This means we can call Pytest inside the anchor test workflow. This is more limited than the Pytest plugin but is more like the standard Anchor way of doing things. Here's how the basic-1 tests look using anchor test and Pytest (but not the ): # test_basic_1.py import asyncio from pathlib import Path from pytest import fixture , mark from anchorpy import create_workspace , close_workspace , Context , Program from solders.keypair import Keypair from solders.system_program import ID as SYS_PROGRAM_ID # Since our other fixtures have module scope, we need to define # this event_loop fixture and give it module scope otherwise # pytest-asyncio will break. @fixture ( scope = \"module\" ) def event_loop (): \"\"\"Create an instance of the default event loop for each test case.\"\"\" loop = asyncio . get_event_loop_policy () . new_event_loop () yield loop loop . close () @fixture ( scope = \"module\" ) async def program () -> Program : workspace = create_workspace () yield workspace [ \"basic_1\" ] await close_workspace ( workspace ) @fixture ( scope = \"module\" ) async def initialized_account ( program : Program ) -> Keypair : my_account = Keypair () await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = { \"my_account\" : my_account . pubkey (), \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID , }, signers = [ my_account ], ), ) return my_account @mark . asyncio async def test_create_and_initialize_account ( program : Program , initialized_account : Keypair ) -> None : \"\"\"Test creating and initializing account in single tx.\"\"\" account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . pubkey ()) assert account . data == 1234 @mark . asyncio async def test_update_previously_created_account ( initialized_account : Keypair , program : Program ) -> None : \"\"\"Test updating a previously created account.\"\"\" await program . rpc [ \"update\" ]( 4321 , ctx = Context ( accounts = { \"myAccount\" : initialized_account . pubkey ()}) ) account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . pubkey ()) assert account . data == 4321 Just paste this code into a file called test_basic_1.py in anchor/examples/tutorial/basic-1/tests/ , and change the scripts section of Anchor.toml to look like this: [scripts] test = \"pytest\" Then run anchor test and voila!. Note You must have pytest-asyncio installed for test_basic_1.py to work.","title":"Testing with AnchorPy"},{"location":"testing/#testing-with-anchorpy","text":"","title":"Testing with AnchorPy"},{"location":"testing/#approaches","text":"There are two ways to test Anchor programs using AnchorPy: Using the AnchorPy Pytest plugin. Using anchor test and modifying Anchor.toml .","title":"Approaches"},{"location":"testing/#1-pytest-plugin","text":"AnchorPy provides a workspace_fixture function that creates a Pytest fixture. This fixture runs anchor localnet in the project root and shuts down the localnet when the tests are done. With this approach you're just running regular Pytest tests. This lets you do some things that you can't do with anchor test , like integrating closely with your IDE or opening a debugger when a test fails ( pytest --pdb ). Here's how it looks with the basic-1 tests: from pytest import fixture , mark from solders.keypair import Keypair from solders.system_program import ID as SYS_PROGRAM_ID from anchorpy import Context , Program , workspace_fixture , WorkspaceType workspace = workspace_fixture ( \"anchor/examples/tutorial/basic-1\" ) # Since our other fixtures have module scope, we need to define # this event_loop fixture and give it module scope otherwise # pytest-asyncio will break. @fixture ( scope = \"module\" ) def event_loop (): \"\"\"Create an instance of the default event loop for each test case.\"\"\" loop = asyncio . get_event_loop_policy () . new_event_loop () yield loop loop . close () @fixture ( scope = \"module\" ) def program ( workspace : WorkspaceType ) -> Program : \"\"\"Create a Program instance.\"\"\" return workspace [ \"basic_1\" ] @fixture ( scope = \"module\" ) async def initialized_account ( program : Program ) -> Keypair : \"\"\"Generate a keypair and initialize it.\"\"\" my_account = Keypair () await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = { \"my_account\" : my_account . pubkey (), \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID , }, signers = [ my_account ], ), ) return my_account @mark . asyncio async def test_create_and_initialize_account ( program : Program , initialized_account : Keypair , ) -> None : \"\"\"Test creating and initializing account in single tx.\"\"\" account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . pubkey ()) assert account . data == 1234 @mark . asyncio async def test_update_previously_created_account ( initialized_account : Keypair , program : Program , ) -> None : \"\"\"Test updating a previously created account.\"\"\" await program . rpc [ \"update\" ]( 4321 , ctx = Context ( accounts = { \"my_account\" : initialized_account . pubkey ()}), ) account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . pubkey ()) assert account . data == 4321 You can just run these tests with pytest (or have your IDE run them). Note There is also a lower-level localnet_fixture function that sets up a localnet for a particular project but doesn't return a workspace.","title":"1. Pytest plugin"},{"location":"testing/#2-anchor-test","text":"Anchor lets you run whatever tests you want using the [scripts] section of Anchor.toml . This means we can call Pytest inside the anchor test workflow. This is more limited than the Pytest plugin but is more like the standard Anchor way of doing things. Here's how the basic-1 tests look using anchor test and Pytest (but not the ): # test_basic_1.py import asyncio from pathlib import Path from pytest import fixture , mark from anchorpy import create_workspace , close_workspace , Context , Program from solders.keypair import Keypair from solders.system_program import ID as SYS_PROGRAM_ID # Since our other fixtures have module scope, we need to define # this event_loop fixture and give it module scope otherwise # pytest-asyncio will break. @fixture ( scope = \"module\" ) def event_loop (): \"\"\"Create an instance of the default event loop for each test case.\"\"\" loop = asyncio . get_event_loop_policy () . new_event_loop () yield loop loop . close () @fixture ( scope = \"module\" ) async def program () -> Program : workspace = create_workspace () yield workspace [ \"basic_1\" ] await close_workspace ( workspace ) @fixture ( scope = \"module\" ) async def initialized_account ( program : Program ) -> Keypair : my_account = Keypair () await program . rpc [ \"initialize\" ]( 1234 , ctx = Context ( accounts = { \"my_account\" : my_account . pubkey (), \"user\" : program . provider . wallet . public_key , \"system_program\" : SYS_PROGRAM_ID , }, signers = [ my_account ], ), ) return my_account @mark . asyncio async def test_create_and_initialize_account ( program : Program , initialized_account : Keypair ) -> None : \"\"\"Test creating and initializing account in single tx.\"\"\" account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . pubkey ()) assert account . data == 1234 @mark . asyncio async def test_update_previously_created_account ( initialized_account : Keypair , program : Program ) -> None : \"\"\"Test updating a previously created account.\"\"\" await program . rpc [ \"update\" ]( 4321 , ctx = Context ( accounts = { \"myAccount\" : initialized_account . pubkey ()}) ) account = await program . account [ \"MyAccount\" ] . fetch ( initialized_account . pubkey ()) assert account . data == 4321 Just paste this code into a file called test_basic_1.py in anchor/examples/tutorial/basic-1/tests/ , and change the scripts section of Anchor.toml to look like this: [scripts] test = \"pytest\" Then run anchor test and voila!. Note You must have pytest-asyncio installed for test_basic_1.py to work.","title":"2. Anchor test"}]}